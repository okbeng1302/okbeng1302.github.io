<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java-stack 类]]></title>
    <url>%2F2017%2F09%2F08%2Fjava-stack%2F</url>
    <content type="text"><![CDATA[JAVA Stack 类栈是Vector的一个子类，他是实现了一个标准的后进先出的栈。 方法： empty()测试堆栈是否为空。 peek()查看堆栈顶部的对象，但不从堆栈中移除它。 pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 push()把项压入堆栈顶部。 search()返回对象在堆栈中的位置，以 1 为基数。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入两个链表，找出它们的第一个公共结点。]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-commonnode%2F</url>
    <content type="text"><![CDATA[输入两个链表，找出它们的第一个公共结点。思路:使用 stack 1234567class LinkNode&#123; int val; LinkNode next = null; LinkNode(int val)&#123; this.val = val; &#125;&#125; 代码实现1234567891011121314151617181920212223import java.util.Stack;public class Solution&#123; public LinkNode FindCommonNode(LinkNode list1,LinkNode list2)&#123; Stack&lt;LinkNode&gt; stack1 = new Stack&lt;LinkNode&gt;(); Stack&lt;LinkNode&gt; stack2 = new Stack&lt;LinkNode&gt;(); LinkNode result = null; while(list1 != null)&#123; stack1.push(list1); list1 = list1.next; &#125; while(list2 != null)&#123; stack2.push(list2); list2 = list2.next; &#125; // 只要 两个链表中的值相等，就进入循环，直到循环结束，最后一次相等的值就是首次相等的值 while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty() &amp;&amp; stakc1.peek() == stack2.peek())&#123; stack1.pop(); result = stack2.pop(); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树转换成双向链表]]></title>
    <url>%2F2017%2F09%2F08%2FTwoTree-linklist%2F</url>
    <content type="text"><![CDATA[输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。思路： 利用二叉树的中序遍历是是递增的。 12345 5 3 81 4 6 9中序遍历(左根右): 1 3 4 5 6 8 9 代码实现： 12345678public class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930import java.util.Stack;public class Solution&#123; public TreeNode Convert(TreeNode root)&#123; if(root == null) return null; TreeNode p = root; TreeNode pre = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); boolean isFirst = true; // 确定首节点 while(p!=null || !stack.isEmpty())&#123; while(p != null!)&#123; stack.push(p); p = p.left; &#125; p = stack.pop(); // 确定首节点 if(isFirst)&#123; root = p; // 首节点 pre = root; // 前一节点 isFirst = fasle; &#125;else&#123; pre.right = p; // 前一节点右指向当前节点 p.left = pre; // 当前节点左指向前一节点 pre = p; //当前节点变为前一节点 &#125; p = pre.right; // 取右节点 &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并两个链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-merge-two%2F</url>
    <content type="text"><![CDATA[输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。非递归版本123456789/*public class ListNode&#123; int val; ListNode node = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution&#123; public ListNode merge(ListNode list1,ListNode list2)&#123; if(list1 == null) return list2; if(list2 == null) return list1; // 确定头结点 ListNode head = null; // 保存当前节点 ListNode current = null; // 当list1 和 list2 都不为空时，比较两个链表的值 while(list1 != null &amp;&amp; list2 != null)&#123; // 如果list1的值比list2的值较小 if(list1.val&lt;=list2.val)&#123; // 确定头结点 if(head == null)&#123; head = current = list1; &#125;else&#123; current.next = list1; // 保存当前节点 current = current.next; &#125; // 下一节点 list1 = list1.next; &#125;else&#123; // 确定头结点 if(head == null)&#123; head = current = list2; &#125;else&#123; current.next = list2; current = current.next; &#125; list2 = list2.next; &#125; &#125; if(list1 == null)&#123; current.next = list2; &#125; if(list2 == null)&#123; current.next = list1; &#125; return head; &#125;&#125; 递归版本1234567891011121314151617public class Solution&#123; public ListNode Merge(ListNode list1,ListNode list2)&#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val&lt;=list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入一个链表从尾到头进行打印]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-tail-head%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表输入一个链表，从尾到头打印链表每个节点的值。 思路：利用 栈 的先进后出的原则123456789/*public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122import java.util.Stack;import java.util.ArrayList;public class Solution&#123; public ArrayList&lt;Integer&gt; PrintTailToHead(ListNode node)&#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); if(node == null)&#123; return result; &#125; ListNode head = node; while(head.next != null)&#123; stack.push(head.val); head = head.next; &#125; stack.push(head.val); while(!stack.isEmpty())&#123; result.add(stack.pop()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻转链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-reverse%2F</url>
    <content type="text"><![CDATA[翻转链表1-&gt;2-&gt;3-&gt;4-&gt;5head = 1next = 2 1-&gt;2 保存1到2 的指针防止造成断链 null&lt;-1 2-&gt;3..-&gt;5head.next = pre 1-&gt;nullpre = 1head = next = 2 head = 2next = 3 2-&gt;3head.next = pre = 1 1&lt;-2-&gt;3..-&gt;5pre = head = 2head = next = 3… 123456789101112131415161718192021222324public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;public class Solution&#123; public ListNode ReverseList(ListNode listnode)&#123; if(listnode == null) return null; ListNode next = null; // 保存当前节点指向下一节点的指针 ListNode pre = null; // 保存当前节点的上一个节点 while(head != null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP&&UDP常见面试题]]></title>
    <url>%2F2017%2F09%2F07%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP协议和UDP协议的区别是什么 TCP保证数据按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，只是努力交付。 TCP协议所需资源较多，TCP首部需20字节（不算可选项），UDP首部字段只需8字节。 TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率。 TCP是一对一的连接，UDP支持一对一，多对多，一对多的通信。 TCP是面向的字节流的服务，UDP是面向的报文的服务。 请详细介绍TCP协议建立连接和终止连接的过程？ 建立连接：三次握手 关闭连接：四次挥手 常见的应用中有那些是应用TCP协议的，那些是UDP协议的，为什么？ 以下应用一般或必须使用UDP实现？ 多播的信息一定要用UDP实现，因为TCP只支持一对一通信。 如果一个应用场景中大多是简短的信息，适合用UDP实现，因为udp是基于报文的它直接上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输速率。 如果一个应用场景性能甚于完整性和安全性，那么适合udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达速度快，因此比较适合udp。 如果要求快速响应，那么udp比较合适。 如果有要利用udp的快速响应有点，又想可靠传输，那么只能靠上层应用自己制定规则。 常见的使用UDP的例子：ICQ，QQ的聊天模块。 以qq为例：登录采用TCP协议和http协议，和好友间的信息发送，主要用udp协议，内网文件传输采用p2p技术。 登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pyspider windows 下环境搭建]]></title>
    <url>%2F2017%2F09%2F07%2Fpyspider-environment%2F</url>
    <content type="text"><![CDATA[依赖 lxml（建议采用windows 编译好的） pycurl phantomjs(将 phantomjs.exe 放在python path 路径下即可) 建议采用 python2.7 32bit（windows环境下）1# pip install pyspider 注意：用pip下载的pyspider不是最新版本，在使用phantomjs进行渲染的时候，发现无法使用 代理 和 执行 js动作，需要更新pyspider 的 fetch_script.js 文件，[pyspider](https://github.com/binux/pyspider)地址 运行1# pyspider all 打开浏览器，输入 localhost:5000 即可dashboard 界面 点击 create ，填写项目名称，开始爬行之旅 搭建完成。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyspider</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lru 计算缺页]]></title>
    <url>%2F2017%2F09%2F07%2Flru%2F</url>
    <content type="text"><![CDATA[在一个请求页式存储管理中，一个程序的页面走向为 3、4、2、1、4、5、3、4、5、1、2，并采用 LRU 算法。设分配给该程序的存储块数 S 分别为 3 和 4，在该访问中发生的缺页次数 F 是 ?解： LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的。 123456789101112131415161718以下用x表示缺页的情况1.S=33,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 5 1 3 4 2 1 4 5 4 3 5x x x x x x x x所以F=82.S=43,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 3 1 3 4 2 1 4 5 4 5 3 3 3 2 1 1 1 4 5x x x x x x x所以F=7]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 navicat 破解]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos%2F</url>
    <content type="text"><![CDATA[破解方案： 第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。 cd /home/hadoop/.navicat/此文件夹下有一个system.reg文件 rm system.reg 把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql的配置修改]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos1%2F</url>
    <content type="text"><![CDATA[linux下mysql的配置修改 使用CentOS下yum安装mysql mysql启动和停止等操作 12345678910111213141516# /etc/init.d/mysqld start;# service mysqld start;#service mysqld stop;#/etc/init.d/mysqld stop;# service mysqld restart;#/etc/init.d/mysqld restart;#service mysqld status;设置新的最大连接数为200：mysql&gt; set GLOBAL max_connections=200 显示当前运行的Query：mysql&gt; show processlist 显示当前状态：mysql&gt; show status 退出客户端：mysql&gt; exit mysql配置文件 以使用的MySQL配置文件共有５个。最后４个位于/usr/share/mysql-server-*/目录中。·/etc/my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。 mysql配置参数一般我们会把配置文件（例如：my-small.cnf）拷贝到/etc/my.cnf只需要修改这个配置文件就可以了，使用mysqladmin variables extended-status -u root -p可以看到目前的参数，有3个配置参数是最重要的，即123key_buffer_size,query_cache_size,table_cache。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
</search>
