<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java-equals方法和hashCode方法]]></title>
    <url>%2F2017%2F09%2F09%2Fjava-hashmap%2F</url>
    <content type="text"><![CDATA[HashMap工作原理Object类的两个方法： 1234567/** JNI ,调用底层其他语言实现*/public native int hashCode();/** 默认同==,直接比较对象 */public boolean equals(Object o)&#123; return (this == o);&#125; hashCode是本地方法,返回的是对象的地址值。对象的equals()比较的是两个对象的地址值,如果equals()相等,hashCode()肯定也相等。 String 类中重写了equals方法，比较的是字符串的值，源码实现: 12345678910111213141516171819202122public boolean equals(Object o)&#123; if(this == o)&#123; return true; &#125; if(o instanceof String)&#123; String anString = (String)o; int n = value.length; if(n == anString.value.length)&#123; char[] v1 = value; char[] v2 = anString.value; int i = 0; while(n-- != 0)&#123; if(v1[i] != v2[i])&#123; return false; &#125; i++; &#125; return true; &#125; &#125; return false;&#125; 重写equals的四个条件： 自反性：对于任何非空引用值x，x.equals(x)都返回true。 对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值x,x.equals(null)都应返回 false。 Object 对象: 对于任何非空引用值 x 和 y,当且仅当 x 和 y 引用同一个对象时,此方法才返回 true。 当equals重写时,hashCode 方法也要重写。 相同的对象必须有相同的哈希码。 equals() 相等的两个对象,hashCode()一定相等;equals 不相等的两个对象,不能证明他们的hashCode不相等.可能是由于哈希碰撞产生的。hashCode()不相等的两个对象,equals也肯定不相等。 下面看一个具体的例子： 1234567891011121314151617181920212223242526272829303132333435package com.xiaobai.demo; public class RectObject &#123; public int x; public int y; public RectObject(int x,int y)&#123; this.x = x; this.y = y; &#125; @Override public int hashCode()&#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj)&#123; if(this == obj) return true; if(obj == null) return false; if(getClass() != obj.getClass()) return false; final RectObject other = (RectObject)obj; if(x != other.x)&#123; return false; &#125; if(y != other.y)&#123; return false; &#125; return true; &#125; &#125; 重写了父类Object中的hashCode和equals方法，看到hashCode和equals方法中，如果两个RectObject对象的x,y值相等的话他们的hashCode值是相等的，同时equals返回的是true;下面是测试代码： 123456789101112131415package com.xiaobai.demo; import java.util.HashSet; public class Demo &#123; public static void main(String[] args)&#123; HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;(); RectObject r1 = new RectObject(3,3); RectObject r2 = new RectObject(5,5); RectObject r3 = new RectObject(3,3); set.add(r1); set.add(r2); set.add(r3); set.add(r1); System.out.println(&quot;size:&quot;+set.size()); &#125; &#125; 运行结果:size:2为什么会是2呢？这个很简单了吧，因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象 下面我们把RectObject对象中的hashCode方法注释，即不重写Object对象中的hashCode方法，在运行一下代码： 运行结果：size:3这个结果也是很简单的，首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3 下面我们把RectObject对象中的equals方法中的内容注释，直接返回false，不注释hashCode方法，运行一下代码： 运行结果：size:3这个结果就有点意外了，我们来分析一下：首先r1和r2的对象比较hashCode，不相等，所以r2放进set中，再来看一下r3,比较r1和r3的hashCode方法，是相等的，然后比较他们两的equals方法，因为equals方法始终返回false,所以r1和r3也是不相等的，r3和r2就不用说了，他们两的hashCode是不相等的，所以r3放进set中，再看r4,比较r1和r4发现hashCode是相等的，在比较equals方法，因为equals返回false,所以r1和r4不相等，同一r2和r4也是不相等的，r3和r4也是不相等的，所以r4可以放到set集合中，那么结果应该是size:4,那为什么会是3呢？这时候我们就需要查看HashSet的源码了，下面是HashSet中的add方法的源码： 123456789101112131415/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null ? e2==null : e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; 这里我们可以看到其实HashSet是基于HashMap实现的，我们在点击HashMap的put方法，源码如下： 12345678910111213141516171819202122232425262728293031/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 我们主要来看一下if的判断条件，首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。 最后我们在来看一下hashCode造成的内存泄露的问题：看一下代码：1234567891011121314151617package com.xiaobai.demo; import java.util.HashSet; public class Demo &#123; public static void main(String[] args)&#123; HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;(); RectObject r1 = new RectObject(3,3); RectObject r2 = new RectObject(5,5); RectObject r3 = new RectObject(3,3); set.add(r1); set.add(r2); set.add(r3); r3.y = 7; System.out.println(&quot;删除前的大小size:&quot;+set.size()); set.remove(r3); System.out.println(&quot;删除后的大小size:&quot;+set.size()); &#125; &#125; 运行结果：删除前的大小size:3删除后的大小size:3 发现一个问题了，而且是个大问题呀，我们调用了remove删除r3对象，以为删除了r3,但事实上并没有删除，这就叫做内存泄露，就是不用的对象但是他还在内存中。所以我们多次这样操作之后，内存就爆了。看一下remove的源码： 123456789101112131415/** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null ? e==null : o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; 然后再看一下remove方法的源码： 12345678910111213/** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; 在看一下removeEntryForKey方法源码：12345678910111213141516171819202122232425262728293031/** * Removes and returns the entry associated with the specified key * in the HashMap. Returns null if the HashMap contains no mapping * for this key. */ final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; 我们看到，在调用remove方法的时候，会先使用对象的hashCode值去找到这个对象，然后进行删除，这种问题就是因为我们在修改了r3对象的y属性的值，又因为RectObject对象的hashCode方法中有y值参与运算,所以r3对象的hashCode就发生改变了，所以remove方法中并没有找到r3了，所以删除失败。即r3的hashCode变了，但是他存储的位置没有更新，仍然在原来的位置上，所以当我们用他的新的hashCode去找肯定是找不到了。其实上面的方法实现很简单的：如下图： !(hashset)[http://img.blog.csdn.net/20140401160554968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/] 很简单的一个线性的hash表，使用的hash函数是mod,源码如下： 123456/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 这个其实就是mod运算，只是这种运算比%运算要高效。1,2,3,4,5表示是mod的结果，每个元素对应的是一个链表结构，所以说想删除一个Entry的话，首先得到hashCode，从而获取到链表的头结点，然后再遍历这个链表，如果hashCode和equals相等就删除这个元素。上面的这个内存泄露告诉我一个信息：如果我们将对象的属性值参与了hashCode的运算中，在进行删除的时候，就不能对其属性值进行修改，否则会出现严重的问题。 其实我们也可以看一下8种基本数据类型对应的对象类型和String类型的hashCode方法和equals方法。其中8中基本类型的hashCode很简单就是直接返回他们的数值大小，String对象是通过一个复杂的计算方式，但是这种计算方式能够保证，如果这个字符串的值相等的话，他们的hashCode就是相等的。8种基本类型的equals方法就是直接比较数值，String类型的equals方法是比较字符串的值的。 参考:http://blog.csdn.net/jiangwei0910410003/article/details/22739953]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串中找出连续最长的数字串]]></title>
    <url>%2F2017%2F09%2F09%2FFindLongNum%2F</url>
    <content type="text"><![CDATA[题目描述读入一个字符串str，输出字符串str中的连续最长的数字串 输入描述:个测试输入包含1个测试用例，一个字符串str，长度不超过255。 输出描述:在一行内输出str中里连续最长的数字串。 示例11234输入abcd12345ed125ss123456789输出123456789 思路： 1. 定义一个值，数字字符串的长度 2. 定义StringBuilder，保存数字字符串 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); char[] ch = s.toCharArray(); int max = 0; // 保存最终最大值的长度 int temp = 0; // 保存当前连续数字字符串的长度 String result = &quot;&quot;; // 保存对吼的字符串结果 StringBuilder sb = new StringBuilder(); // 保存当前的连续数字字符串 for(int i=0;i&lt;ch.length;i++)&#123; if(Character.isDigit(ch[i]))&#123; temp++; sb.append(ch[i]); &#125;else&#123; sb.delete(0,sb.length()); temp = 0; &#125; if(temp &gt; max)&#123; max = temp; result = sb.toString(); &#125; &#125; System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fibonacci 数列]]></title>
    <url>%2F2017%2F09%2F09%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[题目描述Fibonacci数列是这样定义的：F[0] = 0F[1] = 1for each i ≥ 2: F[i] = F[i-1] + F[i-2]因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, …，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。 输入描述输入为一个正整数N(1 ≤ N ≤ 1,000,000) 输出描述输出一个最小的步数变为Fibonacci数” 思路： 判断 N 与相邻两个数的差的大小，以 N 作为界限 代码实现1234567891011121314151617import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int Num = in.nextInt(); int a = 0; int b = 1; while(b&lt;=Num)&#123; int tmp = a + b; a = b; b = tmp; &#125; int result = (b-Num)&gt;(Num-a)?(Num-a):(b-Num); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2017%2F09%2F08%2Ftreenode-reconstruct%2F</url>
    <content type="text"><![CDATA[重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 前序遍历根左右 中序遍历左根右 后序遍历左右根 思路： 已知前序遍历和中序遍历的结果，前序遍历可以推出 根节点，中序遍历可以推出左子树和右子树 例如： * 前序遍历序列： {1,2,4,7,3,5,6,8} 确认根节点为 1 * 中序遍历序列： {4,7,2,1,5,3,8,6} 找到根节点索引，根节点左边即为左子树：{4,7,2} ，右子树：{5,3,8,6} * 依次确定： * 左子树 前序遍历为 {2,4,7} 中序遍历为 {4,7,2} * 右子树 前序遍历为 {3,5,6,8} 中序遍历为 {5,3,8,6} .... 代码实现：12345678class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Solution&#123; public static void main(String args[])&#123; int[] pre = &#123;1,2,4,7,3,5,6,8&#125;; int[] in = &#123;4,7,2,1,5,3,8,6&#125;; TreeNode result = TreeNodeConstruct(pre,in); &#125; public static TreeNode TreeNodeConstruct(int[] pre,int[] in)&#123; ArrayList&lt;Integer&gt; preList = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; inList = new ArrayList&lt;Integer&gt;(); for(int i:pre)&#123; preList.add(pre); &#125; for(int j:in)&#123; inList.add(j); &#125; return getRoot(preList,inList); &#125; public static TreeNode getRoot(List&lt;Integer&gt; preList,List&lt;Integer&gt; inList)&#123; if(preList.size() == 0)&#123; return null; &#125; int val = preList.get(0); // 获取根节点 TreeNode root = new TreeNode(val); int index = inList.indexOf(val); // 获取中序遍历序列中根节点的索引，从而确定中序遍历左子树和中序遍历右子树 // subList(preIndex,lastIndex) 截取List ,不包含lastIndex ,但是包含 preIndex List&lt;Integer&gt; inLeft = inList.subList(0,index); // 获取中序遍历左子树 List&lt;Integer&gt; inRight = inList.subList(index+1,inList.size()); // 获取中序遍历右子树 List&lt;Integer&gt; preLeft = preList.subList(1,inLeft.size()+1); // 获取前序遍历左子树 List&lt;Integer&gt; preRight = preList,subList(inLeft+1,preList.size()); // 获取前序遍历右子树 root.left = getRoot(preLeft,inLeft); root.right = getRoot(preRight,inRight); return root; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java-stack 类]]></title>
    <url>%2F2017%2F09%2F08%2Fjava-stack%2F</url>
    <content type="text"><![CDATA[JAVA Stack 类栈是Vector的一个子类，他是实现了一个标准的后进先出的栈。 方法： empty()测试堆栈是否为空。 peek()查看堆栈顶部的对象，但不从堆栈中移除它。 pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 push()把项压入堆栈顶部。 search()返回对象在堆栈中的位置，以 1 为基数。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入两个链表，找出它们的第一个公共结点。]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-commonnode%2F</url>
    <content type="text"><![CDATA[输入两个链表，找出它们的第一个公共结点。思路:使用 stack 1234567class LinkNode&#123; int val; LinkNode next = null; LinkNode(int val)&#123; this.val = val; &#125;&#125; 代码实现1234567891011121314151617181920212223import java.util.Stack;public class Solution&#123; public LinkNode FindCommonNode(LinkNode list1,LinkNode list2)&#123; Stack&lt;LinkNode&gt; stack1 = new Stack&lt;LinkNode&gt;(); Stack&lt;LinkNode&gt; stack2 = new Stack&lt;LinkNode&gt;(); LinkNode result = null; while(list1 != null)&#123; stack1.push(list1); list1 = list1.next; &#125; while(list2 != null)&#123; stack2.push(list2); list2 = list2.next; &#125; // 只要 两个链表中的值相等，就进入循环，直到循环结束，最后一次相等的值就是首次相等的值 while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty() &amp;&amp; stakc1.peek() == stack2.peek())&#123; stack1.pop(); result = stack2.pop(); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树转换成双向链表]]></title>
    <url>%2F2017%2F09%2F08%2FTwoTree-linklist%2F</url>
    <content type="text"><![CDATA[输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。思路： 利用二叉树的中序遍历是是递增的。 12345 5 3 81 4 6 9中序遍历(左根右): 1 3 4 5 6 8 9 代码实现： 12345678public class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930import java.util.Stack;public class Solution&#123; public TreeNode Convert(TreeNode root)&#123; if(root == null) return null; TreeNode p = root; TreeNode pre = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); boolean isFirst = true; // 确定首节点 while(p!=null || !stack.isEmpty())&#123; while(p != null!)&#123; stack.push(p); p = p.left; &#125; p = stack.pop(); // 确定首节点 if(isFirst)&#123; root = p; // 首节点 pre = root; // 前一节点 isFirst = fasle; &#125;else&#123; pre.right = p; // 前一节点右指向当前节点 p.left = pre; // 当前节点左指向前一节点 pre = p; //当前节点变为前一节点 &#125; p = pre.right; // 取右节点 &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并两个链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-merge-two%2F</url>
    <content type="text"><![CDATA[输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。非递归版本123456789/*public class ListNode&#123; int val; ListNode node = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution&#123; public ListNode merge(ListNode list1,ListNode list2)&#123; if(list1 == null) return list2; if(list2 == null) return list1; // 确定头结点 ListNode head = null; // 保存当前节点 ListNode current = null; // 当list1 和 list2 都不为空时，比较两个链表的值 while(list1 != null &amp;&amp; list2 != null)&#123; // 如果list1的值比list2的值较小 if(list1.val&lt;=list2.val)&#123; // 确定头结点 if(head == null)&#123; head = current = list1; &#125;else&#123; current.next = list1; // 保存当前节点 current = current.next; &#125; // 下一节点 list1 = list1.next; &#125;else&#123; // 确定头结点 if(head == null)&#123; head = current = list2; &#125;else&#123; current.next = list2; current = current.next; &#125; list2 = list2.next; &#125; &#125; if(list1 == null)&#123; current.next = list2; &#125; if(list2 == null)&#123; current.next = list1; &#125; return head; &#125;&#125; 递归版本1234567891011121314151617public class Solution&#123; public ListNode Merge(ListNode list1,ListNode list2)&#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val&lt;=list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入一个链表从尾到头进行打印]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-tail-head%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表输入一个链表，从尾到头打印链表每个节点的值。 思路：利用 栈 的先进后出的原则123456789/*public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122import java.util.Stack;import java.util.ArrayList;public class Solution&#123; public ArrayList&lt;Integer&gt; PrintTailToHead(ListNode node)&#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); if(node == null)&#123; return result; &#125; ListNode head = node; while(head.next != null)&#123; stack.push(head.val); head = head.next; &#125; stack.push(head.val); while(!stack.isEmpty())&#123; result.add(stack.pop()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻转链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-reverse%2F</url>
    <content type="text"><![CDATA[翻转链表1-&gt;2-&gt;3-&gt;4-&gt;5head = 1next = 2 1-&gt;2 保存1到2 的指针防止造成断链 null&lt;-1 2-&gt;3..-&gt;5head.next = pre 1-&gt;nullpre = 1head = next = 2 head = 2next = 3 2-&gt;3head.next = pre = 1 1&lt;-2-&gt;3..-&gt;5pre = head = 2head = next = 3… 123456789101112131415161718192021222324public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;public class Solution&#123; public ListNode ReverseList(ListNode listnode)&#123; if(listnode == null) return null; ListNode next = null; // 保存当前节点指向下一节点的指针 ListNode pre = null; // 保存当前节点的上一个节点 while(head != null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP&&UDP常见面试题]]></title>
    <url>%2F2017%2F09%2F07%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP协议和UDP协议的区别是什么 TCP保证数据按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，只是努力交付。 TCP协议所需资源较多，TCP首部需20字节（不算可选项），UDP首部字段只需8字节。 TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率。 TCP是一对一的连接，UDP支持一对一，多对多，一对多的通信。 TCP是面向的字节流的服务，UDP是面向的报文的服务。 请详细介绍TCP协议建立连接和终止连接的过程？ 建立连接：三次握手 关闭连接：四次挥手 常见的应用中有那些是应用TCP协议的，那些是UDP协议的，为什么？ 以下应用一般或必须使用UDP实现？ 多播的信息一定要用UDP实现，因为TCP只支持一对一通信。 如果一个应用场景中大多是简短的信息，适合用UDP实现，因为udp是基于报文的它直接上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输速率。 如果一个应用场景性能甚于完整性和安全性，那么适合udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达速度快，因此比较适合udp。 如果要求快速响应，那么udp比较合适。 如果有要利用udp的快速响应有点，又想可靠传输，那么只能靠上层应用自己制定规则。 常见的使用UDP的例子：ICQ，QQ的聊天模块。 以qq为例：登录采用TCP协议和http协议，和好友间的信息发送，主要用udp协议，内网文件传输采用p2p技术。 登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pyspider windows 下环境搭建]]></title>
    <url>%2F2017%2F09%2F07%2Fpyspider-environment%2F</url>
    <content type="text"><![CDATA[依赖 lxml（建议采用windows 编译好的） pycurl phantomjs(将 phantomjs.exe 放在python path 路径下即可) 建议采用 python2.7 32bit（windows环境下）1# pip install pyspider 注意：用pip下载的pyspider不是最新版本，在使用phantomjs进行渲染的时候，发现无法使用 代理 和 执行 js动作，需要更新pyspider 的 fetch_script.js 文件，[pyspider](https://github.com/binux/pyspider)地址 运行1# pyspider all 打开浏览器，输入 localhost:5000 即可dashboard 界面 点击 create ，填写项目名称，开始爬行之旅 搭建完成。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyspider</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lru 计算缺页]]></title>
    <url>%2F2017%2F09%2F07%2Flru%2F</url>
    <content type="text"><![CDATA[在一个请求页式存储管理中，一个程序的页面走向为 3、4、2、1、4、5、3、4、5、1、2，并采用 LRU 算法。设分配给该程序的存储块数 S 分别为 3 和 4，在该访问中发生的缺页次数 F 是 ?解： LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的。 123456789101112131415161718以下用x表示缺页的情况1.S=33,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 5 1 3 4 2 1 4 5 4 3 5x x x x x x x x所以F=82.S=43,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 3 1 3 4 2 1 4 5 4 5 3 3 3 2 1 1 1 4 5x x x x x x x所以F=7]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 navicat 破解]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos%2F</url>
    <content type="text"><![CDATA[破解方案： 第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。 cd /home/hadoop/.navicat/此文件夹下有一个system.reg文件 rm system.reg 把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql的配置修改]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos1%2F</url>
    <content type="text"><![CDATA[linux下mysql的配置修改 使用CentOS下yum安装mysql mysql启动和停止等操作 12345678910111213141516# /etc/init.d/mysqld start;# service mysqld start;#service mysqld stop;#/etc/init.d/mysqld stop;# service mysqld restart;#/etc/init.d/mysqld restart;#service mysqld status;设置新的最大连接数为200：mysql&gt; set GLOBAL max_connections=200 显示当前运行的Query：mysql&gt; show processlist 显示当前状态：mysql&gt; show status 退出客户端：mysql&gt; exit mysql配置文件 以使用的MySQL配置文件共有５个。最后４个位于/usr/share/mysql-server-*/目录中。·/etc/my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。 mysql配置参数一般我们会把配置文件（例如：my-small.cnf）拷贝到/etc/my.cnf只需要修改这个配置文件就可以了，使用mysqladmin variables extended-status -u root -p可以看到目前的参数，有3个配置参数是最重要的，即123key_buffer_size,query_cache_size,table_cache。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
</search>
