<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【二叉树算法】对称的二叉树]]></title>
    <url>%2F2017%2F10%2F09%2Ftreenode-isSymmertrical%2F</url>
    <content type="text"><![CDATA[【二叉树算法】对称的二叉树请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 代码实现: 12345678910111213141516171819public class Main &#123; public static boolean isSymmetrical(TreeNode node)&#123; if(node == null) return true; return comRoot(node.left,node.right); &#125; public static boolean comRoot(TreeNode left,TreeNode right)&#123; if(left == null) return right == null; if(right == null) return false; if(left.val != right.val) return false; return comRoot(left.left,right.right) &amp;&amp; comRoot(left.right,right.left); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【二叉树算法】判断一颗二叉树是否是平衡二叉树]]></title>
    <url>%2F2017%2F10%2F09%2Ftreenode-balanceTree%2F</url>
    <content type="text"><![CDATA[【二叉树算法】判断一颗二叉树是否是平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 平衡二叉树：左子树和右子树的深度只差不大于1; 代码实现： 123456789101112131415161718192021public class Main&#123; public static boolean isBalanced(TreeNode root)&#123; if(root == null) return true; int left = treeDepth(root.left); int right = treeDepth(root.right); if(Math.abs(left-right)&gt;1)&#123; return false; &#125; return isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; public int treeDepth(TreeNode root)&#123; if(root == null) return 0; int left = treeDepth(root.left); int right = treeDepth(root.right); return (left&gt;right)?(left+1):(right+1); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【二叉树算法】二叉树的镜像]]></title>
    <url>%2F2017%2F10%2F09%2Ftreenode-mirror%2F</url>
    <content type="text"><![CDATA[【二叉树算法】二叉树的镜像将源二叉树转换成他的镜像 代码实现： 123456789101112public class Main&#123; public static void Mirror(TreeNode node)&#123; if(node == null) return; TreeNode tmp = node.left; node.left = node.right; node.right = tmp; Mirror(node.left); Mirror(node.right); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【二叉树算法】求二叉树中结点的最大距离]]></title>
    <url>%2F2017%2F10%2F09%2Ftreenode-findMaxPath%2F</url>
    <content type="text"><![CDATA[求二叉树中结点的最大距离问题描述：结点的距离是指这两个结点之间的边的个数。 主要思想：首先，求左子树距根结点的最大距离，记为 leftMaxDistance；其次，求右子树距根结点的最大距离，记为 rightMaxDistance，那么最大距离就是 maxDistance = leftMaxDistance + rightMaxDistance 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node&#123; int data; Node left; Node right; int leftMaxDistance; int rightMaxDistance; public Node(int data)&#123; this.data = data; this.left = null; this.right = null; &#125;&#125;public class BinaryTree&#123; private int maxLen = 0; private int max(int a,int b)&#123; return a&gt;b?a:b; &#125; public void FindMaxDistance(Node root)&#123; if(root == null) return; if(root.left == null) root.leftMaxDistance = 0; if(root.right == null) root.rightMaxDistance = 0; if(root.left != null) FindMaxDistance(root.left); if(root.right != null) FindMaxDistance(root.right); // 计算左子树中距离根结点的最大距离 if(root.left != null) root.leftMaxDistance = max(root.left.leftMaxDistance,root.left.rightMaxDistance)+1; // 计算右子树中距离根结点的最大距离 if(root.right != null) root.rightMaxDistance = max(root.right.leftMaxDistance,root.right.rightMaxDistance)+1; if(root.leftMaxDistance + root.rightMaxDistance &gt; maxLen) maxLen = root.leftMaxDistance + root.rightMaxDistance; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【二叉树算法】二叉排序树的构建]]></title>
    <url>%2F2017%2F10%2F08%2Ftreenode-constructor%2F</url>
    <content type="text"><![CDATA[二叉树的实现代码代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class TreeNode&#123; public int data; public Node left; public Node right; public TreeNode(int data)&#123; this.data = data; this.left = null; this.right = null; &#125;&#125;public class BinaryTree&#123; private Node root; public BinaryTree()&#123; &#125; // 将data插入到排序的二叉树中 public void insert(int data)&#123; Node newNode = new Node(data); if(root == null) root = newNode; else&#123; Node current = root; Node parent; // 寻找插入的位置 while(true)&#123; parent = current; if(data&lt;current.data)&#123; current = current.left; if(current == null)&#123; parent.left = newNode; return; &#125; &#125;else&#123; current = current.right; if(current == null)&#123; parent.right = newNode; return; &#125; &#125; &#125; &#125; &#125; // 将数值输入构建二叉树 public void buildTree(int[] data)&#123; for(int i=0;i&lt;data.length;i++)&#123; insert(data[i]); &#125; &#125; // 中序遍历二叉树 public void inOrder(TreeNode node)&#123; if(node != null)&#123; inOrder(node.left); System.out.println(node.data); inOrder(node.right); &#125; &#125; public void inOrder()&#123; this.inOrder(this.root); &#125; // 先序遍历二叉树 public void preOrder(TreeNode node)&#123; if(node!=null)&#123; System.out.println(node.data); preOrder(node.left); preOrder(node.right); &#125; &#125; public void preOrder()&#123; this.preOrder(this.root); &#125; // 后序遍历二叉树 public void lastOrder(TreeNode node)&#123; if(node != null)&#123; lastOrder(node.left); lastOrder(node.right); System.out.println(node.data); &#125; &#125; public void lastOrder()&#123; this.lastOrder(this.root); &#125; public static void main(String args[])&#123; BinaryTree br = new BinaryTree(); int[] data = &#123;2,8,7,4,9,3,1,6,7,5&#125; br.buildTree(data); System.out.println(&quot;二叉树中序遍历：&quot;)； br.inOrder(); System.out.println(&quot;二叉树先序遍历：&quot;)； br.preOrder(); System.out.println(&quot;二叉树后序遍历：&quot;)； br.lastOrder(); &#125;&#125; 输出结果：二叉树中序遍历：1 2 3 4 5 6 7 7 8 9二叉树先序遍历：2 1 8 7 4 3 6 5 7 9二叉树后序遍历：1 3 5 6 4 7 7 9 8 2]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java线程】生产者和消费者模式]]></title>
    <url>%2F2017%2F10%2F08%2Fjava-thread-consumerAndproducer%2F</url>
    <content type="text"><![CDATA[【java线程】生产者和消费者模式假设有这样一种情况，桌子上有一个盘子，盘子里只能放一颗鸡蛋，A专门向盘子里放鸡蛋，如果盘子里有鸡蛋，则一直等到盘子里没有鸡蛋，B专门从盘子里拿鸡蛋，如果盘子里没有鸡蛋，则等待直到盘子里有鸡蛋。其实盘子是一个互斥区，每次往盘子里放鸡蛋应该都是互斥的，A的等待其实就是主动放弃锁，B等待时还要提醒A放鸡蛋。 代码实现： 12345678910111213141516171819202122232425public class Plate&#123; List&lt;Object&gt; eggs = new ArrayList&lt;Object&gt;(); public synchronized Object getEgg()&#123; if(eggs.size() == 0)&#123; try&#123; wait(); &#125;catch(InterruptedException e)&#123; &#125; &#125; Object egg = eggs.get(0); eggs.clear(); notify(); return egg; &#125; public synchronized void putEgg(Object egg)&#123; if(eggs.size()&gt;0)&#123; try&#123; wait(); &#125;catch(InterruptedException e)&#123; &#125; &#125; eggs.add(egg); notify(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】位运算]]></title>
    <url>%2F2017%2F10%2F07%2Fjava-calByBinary%2F</url>
    <content type="text"><![CDATA[【算法】位运算如何使用移位操作实现乘法(*2^n)代码实现 123456789101112public class Main&#123; public static int power(int m,int n)&#123; for(int i=0;i&lt;n;i++)&#123; m = m&lt;&lt;1; &#125; return m; &#125; public static void main(String args[])&#123; System.out.println(power(3,3)); System.out.println(power(3,4)); &#125;&#125; 输出结果:2448 如何判断一个数是否为2的n次方代码实现1： 1234567891011121314151617public class Main&#123; public static boolean isPower(int n)&#123; if(n&lt;1) return false; int i = 1; while(i&lt;=n)&#123; if(i==n) return true; i = i &lt;&lt; 1; &#125; return false; &#125; public static void main(String args[])&#123; System.out.println(isPower(4)); System.out.println(isPower(6)); &#125;&#125; 输出结果：truefalse时间复杂度 O(logn) 代码实现2： 1234567public class Main&#123; public static boolean isPower(int n)&#123; if(n&lt;1) return false; int m = n &amp; (n-1); return m == 0; &#125;&#125; 求二进制中1的个数时间复杂度 O(n)代码实现： 123456789101112131415public class Main&#123; public static int countOne(int num)&#123; int count = 0; while(num&gt;0)&#123; if((num&amp;1) == 1) count++; num = num &lt;&lt; 1; &#125; return count; &#125; public static void main(String args[])&#123; System.out.println(countOne(7)); System.out.println(countOne(8)); &#125;&#125; 输出结果：34 改进版： 时间复杂度 O(m) m 是1的个数 1234567891011public class Main&#123; public static int countOne(int n)&#123; int count = 0; while(n&gt;0)&#123; if(n!=0)&#123; n = n &amp; (n-1); count++; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】各种排序算法有什么优劣]]></title>
    <url>%2F2017%2F10%2F07%2Fjava-sort-allmethod%2F</url>
    <content type="text"><![CDATA[【排序算法】各种排序算法有什么优劣 排序算法 最好时间 平均时间 最坏时间 辅助存储 稳定性 备注 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 n较小时比较好 插入排序 O(n) O(n2) O(n2) O(1) 稳定 大部分已有序时比较好 冒泡排序 O(n) O(n2) O(n2) O(1) 稳定 n较小时比较好 快速排序 O(nlogn) O(nlogn) O(n2) O(logn) 不稳定 n大时比较好 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 n大时比较好 希尔排序 O(n) O(nlogn) O(ns) O(1) 不稳定 s是所选分组 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 n较大时比较好 除了以上排序，还有图排序、桶排序、基数排序等。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】归并排序]]></title>
    <url>%2F2017%2F10%2F07%2Fjava-sort-merge%2F</url>
    <content type="text"><![CDATA[【排序算法】归并排序思路： 归并排序是利用递归与分治技术奖数据序列划分成为越来越小的半子表，再对半子表排序，最后在用递归方法将排好序的半子表合并称为越来越大的有序序列。 原理： 对于给定的一组记录(假设共有N个记录),首先将每一个相邻的长度为1的子序列进行归并，得到N/2(向上取整)个长度为2或1的有序子序列,再将其两两合并,反复执行此过程,直到得到一个有序序列。 代码实现： 12345678910111213141516171819202122232425262728293031323334public class Main&#123; public static void merge(int[] arr,low,high)&#123; if(low&lt;high)&#123; int mid = (high+low)/2; merge(arr,low,mid); merge(arr,mid+1;high); mergerSort(arr,low,mid,high); &#125; &#125; public static void mergeSort(int[] arr,int low,int mid,int high)&#123; int[] temp = new int[high-low+i]; int i = low; int j = mid+1; int k = 0; // 把较小的数先移入到数组中 while(i&lt;=mid &amp;&amp; j&lt;=high)&#123; if(arr[i]&gt;arr[j])&#123; temp[k++] = arr[j++]; &#125;else&#123; temp[k++] = arr[i++]; &#125; &#125; while(i&lt;=mid) temp[k++] = arr[i++]; while(j&lt;high) temp[k++] = arr[j++]; for(int k2=0;k2&lt;temp.length;k2++)&#123; arr[k2+low] = temp[k2]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MySQL】MySQL中 MyISAM和InnoDB的区别]]></title>
    <url>%2F2017%2F10%2F07%2Fmysql-InnoDB-MyISAM%2F</url>
    <content type="text"><![CDATA[【MySQL】MySQL中 MyISAM和InnoDB的区别Mysql 数据库中，最常用的两种引擎就是InnoDB和MyIsam。InnoDB是mysql的默认引擎。 事务处理方面MyIsam 强调的是性能，查询的速度比InnoDB类型更快，但是不能提供事务支持。InnoDB提供事务支出。 外键MyIsam 不支持外键。InnoDB 支持外键。 锁MyIsam 只支持表级锁，InnoDB支持表级锁和行级锁，默认使用行级锁，行级锁大幅度提高了多用户并发操作的性能。InnoDB 比较适合插入和更新操作频繁的情况。而MyIsam 适合查询频繁的情况。InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句，Mysql不能确定要扫描的范围，InnoDB同样会锁全表，例如 update table set num=1 where name like %aaa% 。 全文索引MyIsam 支持全文索引，InnoDB 不支持全文索引。InnoDB 从mysql 5.6 开始支持全文索引。 表主键MyIsam 允许没有表的主键的存在。InnoDB 如果没有设定主键，就会自动成一个 6字节 的主键（用户不可见）。 表的具体行数MyIsam: select count() from table,MyIsam 只要简单的读出保存好的行数。因为 MyIsam 内置了一个计数器，count() 时它直接从技术器中读。 InnoDB: 不保存表的具体行数。在执行 select count(*) from table , InnoDB 要扫描整个表来计算有多少行。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】队列构造]]></title>
    <url>%2F2017%2F10%2F06%2Fjava-queue-constructor%2F</url>
    <content type="text"><![CDATA[如何实现队列基于链表的实现代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Node&lt;E&gt; &#123; Node&lt;E&gt; next = null; E data; Node(E data)&#123; this.data = data; &#125;&#125;public class MyQueue&lt;E&gt;&#123; private Node&lt;E&gt; head = null; privete Node&lt;E&gt; tail = null; public boolean isEmpty()&#123; return head==null; &#125; public void put(E data)&#123; Node&lt;E&gt; newNode = new Node&lt;E&gt;(data); if(head == null &amp;&amp; tail == null) head = tail = newNode; else&#123; tail.next = newNode; tail = newNode; &#125; &#125; public E pop()&#123; if(isEmpty()) return null; E data = head.data; head = head.next; return data; &#125; public int size()&#123; int len = 0; Node&lt;E&gt; tmp = head; while(tmp!=null)&#123; tmp = tmp.next; len++; &#125; return len; &#125;&#125; 基于数组的实现(实现线程安全)代码实现 123456789101112131415161718public class MyQueue&lt;E&gt;&#123; private LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); private int size = 0; public synchronized void put(E e)&#123; list.addLast(e); size++; &#125; public synchronized E pop()&#123; size--; return list.removeFirst(); &#125; public synchronized boolean empty()&#123; return size == 0; &#125; public synchronized int size()&#123; return size; &#125;&#125; 使用两个栈模拟队列操作代码实现 1234567891011121314151617181920public class MyQueue&lt;E&gt; &#123; private Stack&lt;E&gt; s1 = new Stack&lt;E&gt;(); private Stack&lt;E&gt; s2 = new Stack&lt;E&gt;(); public synchronized void put(E data)&#123; s1.push(data); &#125; public synchronized E pop()&#123; if(s2.isEmpty())&#123; while(!s1.isEmpty())&#123; s2.push(s1.pop()); &#125; &#125; return s2.pop(); &#125; public synchronized boolean isEmpty()&#123; return s1.isEmpty() &amp;&amp; s2.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】使用O(1)的时间复杂度，求栈中的最小元素]]></title>
    <url>%2F2017%2F10%2F06%2Fjava-stack-findMin%2F</url>
    <content type="text"><![CDATA[【算法】使用O(1)的时间复杂度，求栈中的最小元素思路： 使用两个栈结构，一个用来存储数据，另一个用来存储栈的最小元素。其实思路如下：如果当前入栈的元素比原来栈中的最小值还小，就把这个值压入保存到最小元素的栈中；在出栈时，如果当前出栈的元素恰好为当前栈中的最小元素，保存在最小栈中的元素也出栈，是的当前最小值变为入栈之前那个最小值。 代码实现： 1234567891011121314151617181920212223242526272829303132public class MyStack1&#123; MyStack&lt;Integer&gt; elem; MyStack&lt;Integer&gt; min; public MyStack1()&#123; elem = new MyStack&lt;Integer&gt;(); min = new MyStack&lt;Integer&gt;(); &#125; public void push(int data)&#123; elem.push(data); if(min.isEmpty())&#123; minn.push(data); &#125;else&#123; if(data&lt;min.peek()) min.push(data); &#125; &#125; public int pop()&#123; int topData = elem.peek(); elem.pop(); if(topData == min.peek()) min.pop(); return topData; &#125; public int min()&#123; if(min.isEmpty()) return Integer.MAX_VALUE; else return min.peek(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】栈的构造]]></title>
    <url>%2F2017%2F10%2F06%2Fjava-stack-constructor%2F</url>
    <content type="text"><![CDATA[基于数组的栈的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Arrays;public class MyStack&lt;E&gt; &#123; private Object[] stack; private int size; // 数组中存储元素的个数 public MyStack()&#123; stack = new Object[10]; //初试长度为10 &#125; // 判断栈是否为空 public boolean isEmpty()&#123; return size==0; &#125; public E peek()&#123; if(isEmpty())&#123; return null; &#125; return (E)stack[size-1]; &#125; public E pop()&#123; E e = peek(); stack[size-1] = null; size--; return e; &#125; public E push(E e)&#123; ensureCapacity(size+1); // 检查容量 stack[size++] = e; return e; &#125; public void ensureCapacity(int size)&#123; int len = stack.length; if(size &gt; len)&#123; int newLen = 10; stack = Arrays.copyOf(stack,newLen); &#125; &#125; public static void main(String args[])&#123; MyStack&lt;Integer&gt; s = new MyStack&lt;Integer&gt;(); s.push(1); s.push(2); System.out.println(s.size()); System.out.println(s.pop()); System.out.println(s.pop()); &#125;&#125; 基于链表实现栈代码实现： 123456789101112131415161718192021222324252627282930313233class Node&lt;E&gt;&#123; Node&lt;E&gt; next = null; E data; public Node(E data)&#123; this.data = data; &#125;&#125;public class Stack&lt;E&gt;&#123; Node&lt;E&gt; top = null; public boolean isEmpty()&#123; return top==null; &#125; public void push(E data)&#123; Node&lt;E&gt; newNode = new Node&lt;E&gt;(data); newNode.next = top; top = newNode; &#125; public E pop()&#123; if(this.isEmpty())&#123; return null; &#125; E data = top.data; top = top.next; return data; &#125; public E peek()&#123; if(isEmpty()) return null; return top.data; &#125;&#125; 注意：上述工程不是线程安全的，若要实现线程安全的栈，则需要对入栈和出栈等操作进行同步]]></content>
      <categories>
        <category>算法</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】判断两个链表是否相交]]></title>
    <url>%2F2017%2F10%2F05%2Flinklist-isrelate%2F</url>
    <content type="text"><![CDATA[判断两个链表是否相交如果两个链表相交，那么它们一定有着相同的尾节点 实现思路： 分别遍历两个链表，记录它们的尾结点，如果它们的尾结点相同，那么两个链表相交，否则不相交。 时间复杂度 O(len1+len2) 实现代码： 1234567891011121314public boolean isInterset(Node n1,Node n2)&#123; if(n1 == null || n2 == null) return false; Node tail1 = n1; while(tail1.next != null)&#123; tail1 = tail1.next; &#125; Node tail2 = n2; while(tail2.next != null)&#123; tail2 = tail2.next; &#125; return tail1 == tail2;&#125; 如果相交，找到它们的第一个相交点思路： 首先分别计算 两个链表head1、head2的长度len1和len2(假设len1&gt;len2),接着先对head1遍历(len1-len2),此时两个链表到达相交结点的距离相同。此时同时遍历两个链表，知道遇到相同的节点为止。需要注意的是，在查找相交的第一个结点时，需要先判断两个链表是否相交，只有在相交的情况下才有必要去找它们的交点。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public static Node getFirstMeetNode(Node h1,Node h2)&#123; // 计算h1的长度并且判断h1和h2是否相交 int len1 = 0;len2 = 0; Node tail1 = h1; Node tail2 = h2; // 计算h1的长度和找到h1的尾结点 while(tail1.next != null)&#123; tail1 = tail1.next; len1++; &#125; // 计算h2的长度和找到h2的尾结点 while(tail2.next != null)&#123; tail2 = tail2.next; len2++; &#125; // 判断是否相交 if(tail1 != tail2) return null; // 遍历长的链表|len1-len2| Node t1 = h1; Node t2 = h2; if(len1 &gt; len2)&#123; int d = len1-len2； while(d&gt;0)&#123; t1 = t1.next; d--; &#125; &#125;else&#123; int d = len2-len1; while(d&gt;0)&#123; t2 = t2.next; d--; &#125; &#125; // 找到第一个相遇的节点 while(t1 != t2)&#123; t1 = t1.next; t2 = t2.next; &#125;&#125; 时间复杂度 O(len1+len2)]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】在不知道头指针的情况下删除指定结点]]></title>
    <url>%2F2017%2F10%2F05%2Flinklist-delete-point%2F</url>
    <content type="text"><![CDATA[【算法】在不知道头指针的情况下删除指定结点思路： 若待删除的结点是链表的尾节点，则无法删除，因为删除后无法使前驱结点的next指针为空 若待删除的节点不是尾节点，则可以通过交换这个节点与其后序节点的值，然后删除后续结点。 代码实现： 123456789public boolean deleteNode(Node n)&#123; if(n == null || n.next == null) return fasle; int temp = n.data; n.data = n.next.data; n.next.data = temp; n.next = n.next.next; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】面向兑现给的6个基本原则（设计模式的6个基本原则）]]></title>
    <url>%2F2017%2F10%2F04%2Fjava-designModel-principle%2F</url>
    <content type="text"><![CDATA[【设计模式】6大基本原则 单一职责原则 开放封闭原则 里氏替换原则 接口隔离原则 依赖倒置原则 合成/聚合复用原则 单一职责原则指一个类的功能要单一，一个类只负责一个职责。（高内聚） 开放关闭原则对扩展开放，对修改关闭。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改关闭，意味着一旦涉及完成，就可以独立其工作，而不要对类进行任何修改。 里氏替换原则任何使用基类的地方，都能使用子类替换，而且在替换子类后，系统仍能正常工作。子类一定是增加父类的能力而不是减小父类的能力。 接口隔离原则将接口粒度最小化，将功能划分到每一个不能再分的子角色，为每一个子角色创建接口，通过这样，才不会让接口的实现类实现一些不必要的功能。（高内聚） 依赖倒置原则我们的类依赖与抽象，而不是依赖与具体，即面向接口编程。本质就是通过抽象（抽象类或者接口）是各个类或模块的实现彼此独立，不互相影响，实现模块间的低耦合。减小类间的耦合性。 合成/聚合复用优先使用聚合或合成关系复用的代码]]></content>
      <categories>
        <category>设计模式</category>
        <category>六大基本原则</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】工厂模式]]></title>
    <url>%2F2017%2F10%2F04%2Fjava-designModel-factory%2F</url>
    <content type="text"><![CDATA[【设计模式】工厂模式详解引言 还没有工厂时代:假如还没有工业革命，如果一个客户想要一款宝马车，一般的做法是客户去创建一款宝马车，然后拿来用。 简单工厂模式:后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马。想要什么车，这个工厂就可以建。即工厂可以创建产品。 工厂方法模式:为了满足客户，宝马车系列越来越多，如 320i，523i等系列一个工厂无法创建所有的宝马系列。于是单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类智能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定那个具体工厂才能生产出车。 抽象工厂模式时代，随着客户的要求越来越多，宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。 分类工厂模式主要是为创建对象提供过度接口，以便将创建兑现给的具体过程屏蔽隔离起来，达到提高灵活性的目的。 工厂模式可以分为三类： 简单工厂模式 工厂方法模式 抽象工厂模式 这三种模式从上到下逐步抽象，并且更具一般性。 区别工厂方法模式：一个抽象产品类，可以派生多个具体的产品类。一个抽象工厂类，可以派生出多个具体的工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体的工厂类。每个具体工厂类可以创建多个具体产品类的实例。 区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建过个。 简单工厂模式建立一个工厂（一个函数或一个类方法）来制造新的对象。 分布说明引子：从无到有。客户自检创建宝马车，然后拿来用。 123456789101112131415161718public class BMW320&#123; public BMW320()&#123; System.out.println(&quot;制造 -- 》 BMW320&quot;); &#125;&#125;public class BMW523&#123; public BMW523()&#123; System.out.println(&quot;制造 -- 》 BMW523&quot;); &#125;&#125;public class Customer&#123; public static void main(String args[])&#123; BMW320 bmw320 = new BMW320(); BMW523 bmw523 = new BMW523(); &#125;&#125; 客户需要知道怎么去创建一款车，客户和车就紧密耦合在了一起。为了低耦合，就出现了工厂类，把创建宝马的操作细节都放到了工厂里面去，客户直接使用工厂的创建工厂方法，传入想要的宝马车型号就行了，而不必去知道创建的细节。这就是工业革命了：简单工厂模式 建立一个工厂方法来实现制造新的对象，如图 产品类： 123456789101112131415abstract class BMW&#123; public BMW()&#123; &#125;&#125;public class BMW320 extends BMW&#123; public BMW320()&#123; System.out.prinltn(&quot;制造 -- 》BMW320&quot;); &#125;&#125;public class BMW523 extends BMW&#123; public BMW523()&#123; System.out.println(&quot;制造 -- 》 BMW523&quot;); &#125;&#125; 工厂类： 12345678910111213public class factory&#123; public BMW createBMW(int type)&#123; switch(typer)&#123; case:320 return new BMW320(); case:523 return new BMW523(); default: break; &#125; return null; &#125;&#125; 客户类: 1234567public class Customer&#123; public static void main(String args[])&#123; Factory factory = new Factory(); BMW320 bmw320 = factory.createBMW(320); BMW523 bmw523 = factory.createBMW(523); &#125;&#125; 简单工厂模式有称静态工厂方法模式。它存在的意义就是：定义一个创建对象的接口。 组成： 工厂类角色：本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品。 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中有一个具体类实现。 开闭原则：对扩展开放，对修改封闭.对于产品部分类说,符合;对于工厂部分好像不太理想,应为每增加一类新型车,都需要在工厂类中增加响应的业务逻辑,违背开闭原则. 工厂方法模式工厂方法模式去掉了简单工厂模式中工厂方法的静态属性.是的它可以被子类继承,这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分组. 工厂方法模式组成: 抽象工厂角色:工厂方法模式的核心,与应用程序无关.是具体工厂方法必须实现给的接口或者必须继承的父类.在java中由抽象类或者接口来实现. 具体工厂角色:它含有和具体业务逻辑有关的代码.由应用程序调用以创建抽象类或者接口来实现. 抽象产品角色:它是具体产品继承的父类或者是实现的接口.在java中一般有抽象类或者接口来实现. 具体产品角色:具体工厂所创建的对象就是此角色的实例.在java中由具体的类来实现. 123456789101112131415abstract class BMW&#123; BMW()&#123; &#125;&#125;public class BMW320 extends BMW &#123; public BMW320()&#123; System.out.println(&quot;制造--》BMW320&quot;); &#125;&#125;public class BMW523 extends BMW&#123; public BMW523()&#123; System.out.prinltn(&quot;制造--》BMW523&quot;); &#125;&#125; 创建工厂类： 1234567891011121314151617interface FactoryBMW&#123; BMW createBMW();&#125;public class FactoryBMW320 implements FactoryBMW&#123; @override public BMW createBMW()&#123; return new BMW320(); &#125;&#125;public class FactoryBMW523 implements FactoryBMW&#123; @override public BMW createBMw()&#123; return new BMW523(); &#125;&#125; 客户类： 12345678public class Customer&#123; public static void main(String args[])&#123; FactoryBMW320 factoryBMW320 = new FactoryBMW320(); BMW320 bmw320 = factoryBMW320.createBMW(); FactoryBMW523 factoryBMW523 = new FactoryBMW523(); BMW523 bmw523 = factoryBMW523.createBMW(); &#125;&#125; 抽象工厂模式抽象工厂方法模式是工厂方法模式的升级版本，他用来来创建一组相互依赖的对象。 抽象工厂代码 产品类: 1234567891011121314151617181920212223242526272829303132// 发动机以及型号public interface Engine&#123; &#125;public class EngineA implements Engine&#123; public EngineA()&#123; System.out.println(&quot;制造 -- 》EngineA&quot;); &#125;&#125;public class EngineB implements Engine&#123; public EngineB()&#123; System.out.println(&quot;制造 -- 》EngineB&quot;); &#125;&#125;// 空调以及型号public interface Aircondition&#123;&#125;public class AirconditionA implements Aircondition&#123; public AirconditionA()&#123; System.out.println(&quot;制造 -- 》AirconditionA&quot;); &#125;&#125;public class AirconditionB implements Aircondition&#123; public AirconditionB()&#123; System.out.println(&quot;制造 -- 》AirconditionB&quot;); &#125;&#125; 创建工厂类 1234567891011121314151617181920212223242526272829303132public interface AbstractFactory&#123; // 创建发动机 public Engine createEngine(); // 创建空调 public Aircondition createAircondition();&#125;// 为宝马320 系列生产配件public class FactoryBMW320 implements AbstractFactory&#123; @override public Engine createEngine()&#123; return new EngineA(); &#125; @override public Aircondition createAircondition()&#123; return new AirconditionA(); &#125;&#125;// 为宝马523 系列生产配件public class FactoryBMW523 implements AbstractFactory&#123; @override public Engine createEngine()&#123; return new EngineB(); &#125; @override public Aircondition createAircondition()&#123; return new AirconditionB(); &#125;&#125; 客户类 12345678910111213public class Customer&#123; public static void main(String args[])&#123; // 生产宝马320 FactoryBMW320 factoryBMW320 = new FactoryBMW320(); factoryBMW320.createEngine(); factoryBME320.createAircondition(); // 生产宝马523 FactoryBMW523 factoryBMW523 = new FactoryBMW523(); factoryBMW523.createEngine(); factoryBME523.createAircondition(); &#125;&#125; 最终目的是解耦 喝水不忘挖井人：学习链接(http://blog.csdn.net/jason0539/article/details/44976775)]]></content>
      <categories>
        <category>设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】单例模式]]></title>
    <url>%2F2017%2F10%2F04%2Fjava-designModel-singleton%2F</url>
    <content type="text"><![CDATA[【设计模式】单例模式详解实现方式一： 使用静态内部类实现 123456789public class Singleton &#123; private Singleton()&#123; &#125; private static class T &#123; private static Singleton t = new Singleton(); &#125; public static Singleton getInstance()&#123; return T.t; &#125;&#125; 实现方式二: 使用双重校验所 DCL,使用 volatile 场景之一 1234567891011121314151617public class Singleton &#123; // 使用volatile修饰成员变量后，所有线程在任何时候看到变量的值都是相同的。 private static volatile Singleton instance = null; private Singleton() &#123; &#125; // 双重校验锁，只有在第一次实例化时，才启用同步机制，提高了性能。 public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); // 注意这条语句，非原子操作 &#125; &#125; &#125; return instance; &#125;&#125; 实现方式三:懒汉式单例模式 12345678910public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 单例模式的应用场景 数据库连接池 多线程线程池 Windows的任务管理器]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】链表是否有环]]></title>
    <url>%2F2017%2F10%2F03%2Flinklist-isRound%2F</url>
    <content type="text"><![CDATA[判断链表是否有环思路： 定义两个指针 fast 和 slow，其中 fast 是快指针，slow 是慢指针，二者的初始值都指向头结点。slow每次前进一步，fast每次前进两步，两个指针同时向前移动。快指针每次都要和慢指针进行比较，直到当快指针等于慢指针为止，就证明是带环的链表。 代码实现： 12345678910111213public boolean isLoop(Node head)&#123; Node fast = head; Node slow = head; if(fast == null) return faslse; while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; if(fast = slow) return true; &#125; return !(fast == null || fast.next == null);&#125; 如果链表有环，找到环的入口思路： 当走的快的指针fast 和走的慢的指针slow相遇时，slow 指针肯定没有遍历完链表，而fast已经在环上内循环了n圈（n&gt;=1）。假设 slow 走了 s步，则 fast走了 2s步（fast走的步数还等于 s 加上环的多转的 n 圈），设 环 长 r，则： 2s = s + nrs = nr 设链表的长度 L，入口环和相遇点距离为 x，起点到环入口点的距离 为 a，则： a + x = s = nra + x = (n-1)r + r = (n-1)r + L-aa = (n-1)r + L - a - x L-a-x 是相遇点到环入口的距离，从链表投到环入口点等于(n-1)循环内环 + 相遇点到环入口的点。 s = nr = a + x 代码实现： 1234567891011121314151617181920public Node FindLoopPort(Node head)&#123; Node slow = head; Node fast = head; // 找到相遇点 while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; if(slow == fast) bread; &#125; if(fast == null || fast.next == null) return null; slow = head; while(slow!=fast)&#123; slow = slow.next; fast = fast.next; &#125; return slow;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】单链表的中间节点]]></title>
    <url>%2F2017%2F10%2F03%2Flinklist-findmiddleNode%2F</url>
    <content type="text"><![CDATA[单链表的中间结点思路： 第一步：有两个指针同时从头开始遍历；第二步：一个快指针一次走两步，一个慢指针一次走一步第三步：快指针先到链表尾部，而满指针恰好到达链表中部(快指针到链表尾部时，当链表长度为奇数时，慢指针指向的即是链表的中间节点；当链表长度为偶数时，慢指针指向的节点和慢指针指向的下一个节点都是链表的中间节点) 代码实现： 123456789public Node findMid(Node head)&#123; Node p = head; Node q = head; while(p !=null &amp;&amp; p.next != null &amp;&amp; p.next.next != null)&#123; p = p.next.next; q = q.next; &#125; return q;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】删除链表中的重复数据]]></title>
    <url>%2F2017%2F10%2F03%2Flinklist-delete-repeatedata%2F</url>
    <content type="text"><![CDATA[删除链表中的重复数据思路一：遍历链表,把遍历的值存储到一个Hashtable中，在遍历的过程中，若当前访问的值在Hashtable中已经存在，则说明这个数据是重复的。因此就可以删除。 代码实现： 12345678910111213141516public void deleteDuplecate(Node head)&#123; Hashtable&lt;Integer,Integer&gt; hashtable = new Hashtable&lt;Integer,Integer&gt;(); Node tmp = head; Node pre = null; while(tmp != null)&#123; if(hashtable.containsKey(tmp.data))&#123; pre.next = tmp.next; &#125;else&#123; hashtable.put(tmp.data,1); pre = tmp;// 保存上一节点 &#125; tmp = tmp.next; &#125;&#125; 思路二: 对链表进行双重遍历循环，外循环正常遍历链表，假设外循环当前遍历的节点为cur，内循环从cur开始遍历，若碰到与cur所指向节点值相同，则删除这个重复节点。 代码实现: 1234567891011121314public void deleteDeplecate(Node head)&#123; Node p = head; while(p != null)&#123; Node q = p; while(q.next != null)&#123; if(p.data == q.next.data)&#123; q.next = q.next.next; &#125;else&#123; q = q.next; &#125; &#125; p = p.next; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】链表的基本操作]]></title>
    <url>%2F2017%2F10%2F03%2Flinklist-add-delete-sort%2F</url>
    <content type="text"><![CDATA[如何实现单链表的增删操作代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Node &#123; int data; Node next = null; public Node(int data)&#123; this.data = data; &#125;&#125;public class TestLinkedList &#123; // 头结点 Node head = null; // 向链表中插入结点 public void addNode(int d)&#123; Node newNode = new Node(d); if(head == null)&#123; head = newNode; return ; &#125; // 查找最后一个节点，插入到最后 Node tmp = head; while(tmp.next != null)&#123; tmp = tmp.next; &#125; tmp.next = newNode; &#125; // 删除第几个结点 public boolean deleteNode(int index)&#123; if(index &lt; 1 || index &gt; length())&#123; return false; &#125; // 删除头结点,当前节点的指针指向下一节点的下一节点 if(index == 1)&#123; head = head.next; return true; &#125; int i = 2; Node preNode = head; Node curNode = preNode.next; while(curNode.next!=null)&#123; if(i == index)&#123; preNode.next = curNode.next; return true; &#125; preNode = preNode.next; curNode = curNode.next; i++; &#125; return true; &#125; // 排序,并返回头结点 public Node sortNode()&#123; Node nextNode = null; int temp = 0; Node curNode = head; while(curNode.next != null)&#123; nextNode = curNode; while(nextNode != null)&#123; if(curNode.data &gt; nextNode.data)&#123; temp = curNode.data; curNode.data = nextNode.data; nextNode.data = temp; &#125; nextNode = nextNode.next; &#125; curNode = curNode.next; &#125; return head; &#125; // 计算链表的长度 public int length()&#123; int len = 0; Node preNode = head; while(preNode != null)&#123; len++; preNode = preNode.next; &#125; return len; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络基础】ip分类]]></title>
    <url>%2F2017%2F09%2F30%2Fnetwork-ip%2F</url>
    <content type="text"><![CDATA[【网络基础】IP 分类ip 共5类，A,B,C,D,E A 类 0-127 ，其中 0 代表任何地址，127位回环测试地址，A类ip地址实际范围是 1-126默认子网掩码为 255.0.0.0 0.0.0.0 和 127.0.0.0 保留实际范围是 1.0.0.0 - 126.255.255.255 一个子网最多可容纳1658万多台电脑 B 类128-191 实际范围是 128.0.0.0 和 191.255.255.255默认子网掩码为 255.255.0.0一个子网最多可容纳6万台电脑 C 类 192-223实际范围是192.0.0.0和223.225.255.255 子网掩码默认是 255.255.255.0一个子网最多可容纳254台电脑 D 类224.0.0.0 到 239.255.255.255 用于多点广播 E 类 240.0.0.0 到 255.255.255.254255.255.255.255 用于广播地址]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>ip分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】设计模式详解]]></title>
    <url>%2F2017%2F09%2F30%2Fjava-designModel-list%2F</url>
    <content type="text"><![CDATA[【设计模式】 23中经典设计模式 创建型 类：Factory Method(工厂方法) Abstract Factory(抽象工厂) Builder(生成器) Prototype(原型) Singleton(单例) 结构型 Adapter_Class(适配器类) Adapter_Object(适配器对象) Bridge(桥接) Composite(组合) Decorator(装饰) Facade(外观) Flyweight(享元) Proxy(代理) 行为型 Interpreter(解释器) Template Method(魔板方法) Chain of Responsibility(职责链) Command(命令) Iterator(迭代器) Mediator(中介者) Memento(备忘录) Oberver(观察者) State(状态) Strategy(策略) Visitor(访问者模式)]]></content>
      <categories>
        <category>设计模式</category>
        <category>设计模式详解</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jvm】类加载器 ClassLoader]]></title>
    <url>%2F2017%2F09%2F29%2Fjava-jvm-classloader%2F</url>
    <content type="text"><![CDATA[【java基础】Jvm 类加载器 ClassLoader类的加载方式： 隐式加载：程序在使用 new 等方式创建对象时，对隐式的调用类的加载器把对应的类加载到JVM中。 显示加载：通过直接调用class.forName()方法把所需要的类加载到JVM中。 类加载器： Bootstrap ClassLoader负责加载系统类(jre/lib/rt.jar) ExtClassLoader负责加载扩展类(jre/lib/ext/*.jar) AppClassLoader负责加载应用类(classpath指定的目录或jar中的类) 如何协调工作完成类加载？ 父类委托机制：当有类需要加载时，类加载器会请求父类来完成载入的工作，父类会根据自己的搜索路径来搜索需要被载入的类，如果搜索不到，才会由子类按照其搜索路径来搜索待加载的类。 类加载的主要步骤： 装载：根据查找路径找到相应的class文件，然后导入。 链接： 检查：检查待加载的类文件的正确性。 准备：给类中的静态变量分配存储空间。 解析：将符号引用转换成直接引用（这一步可选）。 初试化：对静态变量和静态代码块执行初始化操作。]]></content>
      <categories>
        <category>java</category>
        <category>JVM 虚拟机</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java基础】反射机制]]></title>
    <url>%2F2017%2F09%2F27%2Fjava-reflect%2F</url>
    <content type="text"><![CDATA[【java基础】反射机制反射机制功能： 得到一个对象所属的类 获取一个类pub的成员变量和方法 在运行时创建对象 在运行时调用对象的方法 1234567891011121314151617181920212223class Base &#123; public void f()&#123; System.out.println(&quot;Base&quot;); &#125;&#125;class Sub extends Base &#123; public void f()&#123; System.out.println(&quot;Sub&quot;); &#125;&#125;public class Test &#123; public static void main(String args[])&#123; try &#123; Class c = Class.forName(&quot;Sub&quot;); Base b = c.new Instance(); b.f(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 输出： Sub 获取Class类： Class.forName(“类的路径”) 类名.Class 实例.Class]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java基础】Clone方式创建对象]]></title>
    <url>%2F2017%2F09%2F27%2Fjava-clone%2F</url>
    <content type="text"><![CDATA[【java基础】 创建对象 Clone()步骤: 实现clone的类首先需要继承 Cloneable 接口。Cloneable接口实质上是一个标识接口，没有接口方法。 在类中重写 Object 类中的clone()方法。 在clone()方法中调用 super.clone().无论clone类的继承结构是什么，super.clone()会直接或间接调用java.lang.Object类的clone()方法。 把浅复制的引用指向原型对象新的克隆体。 代码如下： 123456789101112131415161718192021222324252627282930313233class Obj implements Cloneable&#123; private int aInt = 0; public int getAInt()&#123; return aInt; &#125; public void setAInt(int a)&#123; this.aInt = a; &#125; public void changeAInt()&#123; this.aInt = 1; &#125; public Object clone()&#123; Object o = null; try&#123; o = (Obj)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return o; &#125;&#125;public class Test&#123; public static void main(String args[])&#123; Obj a = new Obj(); Obj b = (Obj)a.clone(); b.changeAInt(); System.out.println(a.aInt); System.out.println(b.aInt); &#125;&#125; 输出： 1201 在 C++ 中,自定义复制构造函数时，会灿在潜复制和深复制 java 的 clone() 方法也存在这个问题当对象中只含有一些基本数据类型时，使用上述方法就可以。但是当类中有 对象 时，需要深复制。 实现方法是在对对象调用clone()方法完成复制后，接着对对象中的非基本类型的属性也调用clone方法完成深复制。 代码实现： 12345678910111213141516171819202122232425262728293031323334import java.util.Date;class Obj implements Cloneable&#123; private Date birth = new Date(); public Date getBirth()&#123; return birth; &#125; public void setBirth(Date birth)&#123; this.birth = birth; &#125; public void changeDate()&#123; this.birth.setMonth(4); &#125; public Object clone()&#123; Obj o = null; try &#123; o = (Obj)super.clone(); &#125; catch(CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; // 实现深复制 o.birth = (Date)this.getBirth().clone(); return o; &#125;&#125;public class Test&#123; public static void main(String args[])&#123; Obj a = new Obj(); Obj b = (Obj)a.clone(); b.changeDate(); System.out.println(a.getBirth()); System.out.println(b.getBirth()); &#125;&#125; 输出： Wed Sep 27 10:21:25 CST 2017Sat May 27 10:21:25 CST 2017]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java基础】创建对象的几种形式]]></title>
    <url>%2F2017%2F09%2F27%2Fjava-create-object%2F</url>
    <content type="text"><![CDATA[【java基础】创建对象的几种方式 使用new关键字 1Employee e = new Employee(); 使用Class类的newInstance方法 这个 newInstance 方法调用无参的构造函数创建对象。 12345Employee e = (Employee)Class.forName(&quot;com.xiaobai.test.Employee&quot;).newInstance;后者：Employee e = Employee.class.newInstance(); 使用Constructor类的newInstance方法 和 Class 类的newInstance方法很像，java.lang.reflect.Constructor 类里也有一个newInstance的方法创建对象。 12Constructor&lt;Employee&gt; constructor = Employee.class.getConstructor();Employee e = constructor.newInstance(); 使用clone方法 无论何时调用一个对象的clone方法,jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。 要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。 1Employee e = (Employee)e.clone() 使用反序列化 当序列化和反序列化一个对象,jvm会给我们创建一个单独的对象。在反序列时, jvm 创建对象并不会调用任何构造函数。为了反序列化一个对象，需要将类实现Serializable接口 12ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;));Employee e = (Employee) in.readObject(); 除了第1个方法，其他4个方法全都转变为invokevirtual(创建对象的直接方法)，第一个方法转变为两个调用，new和invokespecial(构造函数调用)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Employee implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String name; public Employee() &#123; System.out.println(&quot;Employee Constructor Called...&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return &quot;Employee [name=&quot; + name + &quot;]&quot;; &#125; @Override public Object clone() &#123; Object obj = null; try &#123; obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public class ObjectCreation &#123; public static void main(String... args) throws Exception &#123; // By using new keyword Employee emp1 = new Employee(); emp1.setName(&quot;Naresh&quot;); System.out.println(emp1 + &quot;, hashcode : &quot; + emp1.hashCode()); // By using Class class&apos;s newInstance() method Employee emp2 = (Employee) Class.forName(&quot;org.programming.mitra.exercises.Employee&quot;) .newInstance(); // Or we can simply do this // Employee emp2 = Employee.class.newInstance(); emp2.setName(&quot;Rishi&quot;); System.out.println(emp2 + &quot;, hashcode : &quot; + emp2.hashCode()); // By using Constructor class&apos;s newInstance() method Constructor&lt;Employee&gt; constructor = Employee.class.getConstructor(); Employee emp3 = constructor.newInstance(); emp3.setName(&quot;Yogesh&quot;); System.out.println(emp3 + &quot;, hashcode : &quot; + emp3.hashCode()); // By using clone() method Employee emp4 = (Employee) emp3.clone(); emp4.setName(&quot;Atul&quot;); System.out.println(emp4 + &quot;, hashcode : &quot; + emp4.hashCode()); // By using Deserialization // Serialization ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;data.obj&quot;)); out.writeObject(emp4); out.close(); //Deserialization ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;)); Employee emp5 = (Employee) in.readObject(); in.close(); emp5.setName(&quot;Akash&quot;); System.out.println(emp5 + &quot;, hashcode : &quot; + emp5.hashCode()); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【mysql】 sql 语句深入学习]]></title>
    <url>%2F2017%2F09%2F25%2Fmysql-sql%2F</url>
    <content type="text"><![CDATA[sql语法学习 数据库设计三大范式 第一范式(确保每列保持原子性)第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 简单理解：字段(列)不可分。 第二范式(确保表中的每列都和主键相关)第二范式在第一范式的基础上更近一层。第二范式需要确保数据库表中的每一列都和主键相关。而不能只和主键的某一部分相关(针对联合主键).也就是说在一个数据库表中，一个表只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 简单理解：有主键，非主键字段依赖主键。 第三范式(确保每列都和主键列直接相关，而不是间接相关)第三范式需要确保数据表中的每一列都和主键直接相关，而不能间接相关。 简单理解：每一列都和主键有直接关系，不存在传递依赖。 sql 语法]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java基础】Socket 套接字编程]]></title>
    <url>%2F2017%2F09%2F25%2Fjava-socket%2F</url>
    <content type="text"><![CDATA[【java基础】Socket编程题目描述：使用 socket 编写一个服务器程序，服务器端程序在端口 8888 监听，如果它接到客户端发来的 “hello” 请求时会回应一个 “hello”,对客户端的其他请求不响应。 代码实现 123456789101112131415161718192021222324import java.io.*;import java.net.*;public class HelloServer &#123; public static void main(String args[]) &#123; ServerSocket server = null; server = new ServerSocket(8888); Socket ClientSocket = null; ClientSocket = server.accept(); String line; BufferReader br = new BufferReader(new InputStreamReader(ClientSocket.getInputStream())); PrintWriter pw = new PrintWriter(ClientSocket.getOutputStream()); while(true)&#123; line = br.readLine(); if(line.equals(&quot;hello&quot;))&#123; pw.println(&quot;hello&quot;); pw.close(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】单例模式(一)]]></title>
    <url>%2F2017%2F09%2F24%2Fjava-designModel-siglton%2F</url>
    <content type="text"><![CDATA[单例模式 实例下面一段代码是不是单例模式 12345678910111213141516public class Singleton&#123; private static Singleton singleton; public Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125; public void method(String s)&#123; System.out.println(s); &#125;&#125; 不是单例模式，因为构造方法应该改为私有方法。]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java面试/笔试】SSH]]></title>
    <url>%2F2017%2F09%2F24%2Fjava-yaxin-exam1%2F</url>
    <content type="text"><![CDATA[SSH 笔试/面试 请解释Structs实现MVC的机制 在Structs框架中，模型由实现业务逻辑的javaBean或Ejb组件完成，控制器由ActionServlet和Action来实现，视图由一组Jsp文件构成。 请说明如下 Hibernate 标识符生成器的区别： increment、indentity、sequence、assigned其中哪些是需要依赖底层数据库系统？ Increment:由hibernate自动以自增的方式生成标识符，每次增量为1。 Identity:由底层数据库生成标识符。前提条件底层数据库支持自动增长字段类型。 Sequence:由底层数据库的序列生成标识符。前提条件底层数据库支持序列。 Assigned:由java应用程序负责生成标识符。不能把setId()方法声明为 private类型。 简述Hibernate的Session接口提供的操作数据库的各种方法？ save():把java对象保存到数据库中 update():更新数据中的java对象 delete():把java对象从数据库中删除 load():从数据库中加载java对象 find():从数据库中查询对象 Hibernate load()和 get() 区别 都根据给定的OID从数据库中加载一个持久化对象。区别在于当数据库中不存在与OID对应的记录时，load()方法抛出net.sf.hibernate.ObjectNotFoundException 异常，get() 返回null Hibernate 应用中持久化对象的状态 临时状态：刚刚用new语句创建，还没有持久化，不处于Session的缓存中。出于临时状态的java对象被称为临时对象。 持久化状态：已经被持久化，加入到session的缓存中，处于持久化状态的java对象被称为持久化对象。 游离状态：已经被持久化，但不再处于session的缓存中。称为游离对象。]]></content>
      <categories>
        <category>java</category>
        <category>java 笔试/面试</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java面试/笔试】 Jsp & Servlet & javascript]]></title>
    <url>%2F2017%2F09%2F24%2Fjava-yaxin-exam%2F</url>
    <content type="text"><![CDATA[Java 笔试/面试(一)Jsp &amp; Servlet &amp; javascript 请说明 HttpSession,ServletContext 的作用和区别？ HttpSession : Servlet容器为每一个Http会话创建一个HttpSession实例，HttpSession可以放session范围的共享数据。 ServletContext: servlet 容器为每个web应用创建一个ServletContext 实例，ServletContext 可以存放 application 范围的共享数据。 请解释请求转发与请求重定向的区别？ 请求转发：把请求转发给同一应用程序中的其他web组件。这些组件共享同一个请求对象。 请求重定向：web组件可以将请求重定向到任意URL，而不仅仅是同一应用中的URL；重定向的源组件和目标组件之间不共用一个HttpServletRequest对象，因此不能共享request范围内的共享数据。 简述 Servlet 的声明周期？ Servlet运行机制和Applet类似,Servlet 是在服务器端运行的，但是Applet是在客户端运行的。Servlet 是javax.servlet 包中HttpServlet 类的子类,由服务器完成该子类的创建和初试化。Servlet 的声明周期主要由3个过程组成: init(): 服务器初试化Servlet。 service(): 初始化完毕，Servlet对象调用该方法响应客户的请求。* destroy(): 调用该方法消灭Servlet对象。其中，init() 方法只在Servlet 第一次被请求加载的时候被调用一次,当客户再请求Servlet服务时，Web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。 表单传递数据的两种方式，并说明这两种方式的区别？Get 和 POST get：是把参数数据加到提交变淡的Action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。 post：是通过Http post机制，将表单内各个字段与其内容放在html header 内一起传送到action属性所指的url地址。用户看不到这个过程。 对于get方式，服务器端使用Request.QueryString获取变量的值，对于post方式，服务器端采用Request.Form 获取提交的数据。两种方式的参数都可以用Request来获得。 get传送的数据量小，不能大于2kb。post 传送的数据量较大，一般默认不受限制。但理论上，IIS4 最大 80kb IIS5 最大 100kb get 安全性非常低，post 安全性高 另外，get请求有如下特性：它会将数据添加到URL中，通过这种方式传递给服务器，通常利用一个问号?代表URL地址的结尾与数据参数的开端，后面的参数每一个数据参数以“名=值”的形式出现，参数和参数之间利用一个连接符&amp;来区分。post有如下特性：数据是放在http主体中的，其组织方式不只一种，有&amp;方式，也有分隔符方式，可隐藏参数，传递大批数据，比较方便。]]></content>
      <categories>
        <category>java</category>
        <category>java 笔试/面试</category>
      </categories>
      <tags>
        <tag>jsp/servlet/js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java】Jdbc 数据库访问]]></title>
    <url>%2F2017%2F09%2F24%2Fjava-jdbc%2F</url>
    <content type="text"><![CDATA[Java Jdbc 访问数据库实例 数据库 : mysql 数据库驱动 : com.mysql.jdbc.Driver 数据库Url : jdbc:mysql://127.0.0.1:3306/demo 用户名 : test 用户口令 : 123 在该数据库中，有一张新建立的User表: CREATE TABLE ‘user’(‘id’ int(11) not null auto_increament,’name’ varchar(100) not null default ‘’, ‘age’ int(4), primary key(‘id’)); 请写出一段JDBC程序，完成如下功能: 先向该表中插入一条记录(Tom,15),然后查询出该表中的所有数据,并打印(请考虑资源的回收). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.mysql.jdbc.Connection;import com.mysql.jdbc.Statement;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;public class Demo&#123; public static final String driver = &quot;com.mysql.jdbc.Driver&quot;; public static final String Url = &quot;jdbc:mysql://127.0.0.1:3306/demo&quot;; public static final String user = &quot;test&quot;; public static final String pwd = &quot;123&quot;; public static void main(String args[])&#123; Connection connection = null; Statement stmt = null; ResultSet s = null; try &#123; Class.ForName(driver); conn = DriverManager.getConnection(Url,user,pwd); conn.setAutoCommit(false); stmt = conn.creatStatement(); int count = stmt.executeUpdate(&quot;insert into user(name age) values (&quot;Tom&quot;,25)&quot;); rs = stmt.executeQuery(&quot;select * from user&quot;); while(rs.next())&#123; System.out.println(rs.getInt(1) + &quot;,&quot; + rs.getString(2) + &quot;,&quot; + rs.getInt(3)); &#125; conn.commit(); stmt.close(); conn.close(); &#125; catch (Exception e)&#123; System.out.println(&quot;数据库操作失败:&quot; + e.getMessage()); try &#123; conn.callback(); &#125; catch (SQLException e1)&#123; e1.printStackTrace(); &#125; &#125;finally &#123; try &#123; if(stmt != null) stmt.close(); &#125; catch(SQLException e1) &#123; e1.printStackTrace(); &#125; try &#123; if(conn != null) conn.close(); &#125; catch (SQLException e1)&#123; e1.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>jdbc</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java基础】 switch]]></title>
    <url>%2F2017%2F09%2F24%2Fjava-switch%2F</url>
    <content type="text"><![CDATA[Java 中的 switch语法注意：在java中switch后的表达式的类型只能为一下几种：byte,short,char,int(java1.6中是这样)在java1.7后支持了对String的判断 还有一点，在java中如果switch的case语句中少些了break;这个关键字，在编译的时候并没有报错，但是在执行的时候回一直执行所有的case条件下的语句并不是去判断，所以会一直到遇到break关键字跳出或者一直执行到default语句。 还有就是如果在switch表达的结果在case中没话，switch就会从default执行。 1234567891011121314151617181920212223public class TestSwitch&#123; public static void main(String args[])&#123; char c = &apos;a&apos;; //char类型字符 switch(c)&#123; default: System.out.println(&quot;打印默认值&quot;); break; case &apos;a&apos;: System.out.println(&quot;a&quot;); break; case &apos;b&apos;: System.out.println(&apos;b&apos;); break; case &apos;c&apos;: System.out.println(&apos;c&apos;); break; case &apos;d&apos;: System.out.println(&quot;d&quot;); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[括号匹配]]></title>
    <url>%2F2017%2F09%2F22%2Fmatch%2F</url>
    <content type="text"><![CDATA[括号匹配 判断括号是否匹配，并且打印匹配的括号个数输入的全是: 括号序列例如: ()()()() 打印: Yes 4 (())() 打印: Yes 3 )()( 打印: No ()) 打印: No代码实现: 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;import java.util.Stack;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); check(s); &#125; public static void check(String str)&#123; int count = 0; // 记录匹配括号的个数 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // 如果该String长度为奇数，不匹配 if(str.length() % 2 == 1)&#123; System.out.println(&quot;No&quot;); &#125; else&#123; stack = new Stack&lt;Character&gt;(); for(int i=0;i&lt;str.length();i++)&#123; if(stack.isEmpty())&#123; stack.push(str.charAt(i)); &#125; else if((stack.peek() == &apos;(&apos; &amp;&amp; str.charAt(i) == &apos;)&apos;))&#123; stack.pop(); // 满足上面的条件 表示相邻的两个字符是一对匹配的括号，进行出栈操作 count++; // 记录有多少对 匹配的括号 &#125; else &#123; stack.push(str.charAt(i)); &#125; &#125; if(stack.isEmpty()) &#123; System.out.println(&quot;Yes&quot;); System.out.println(count); &#125;else&#123; System.out.println(&quot;No&quot;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>括号匹配</category>
      </categories>
      <tags>
        <tag>括号匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树深度]]></title>
    <url>%2F2017%2F09%2F22%2Ftreenode-depth%2F</url>
    <content type="text"><![CDATA[代码实现: 递归 写法 123456789public class Solution&#123; public static int treeDepth(TreeNode root)&#123; if(root == null) return 0; int left = treeDepth(root.left); int right = treeDepth(root.right); return (left&gt;right) ? left+1:right+1; &#125;&#125; 非递归写法 12345678910111213141516171819202122232425262728import java.util.Queue;import java.util.LinkedList;public class Solution&#123; public static int treeDepth(TreeNode pRoot)&#123; if(pRoot == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(pRoot); int depth = 0; int count = 0; int nextCount = 1; // 记录每一层的个数 while(queue.size()!=0)&#123; TreeNode top = queue.poll(); count++; if(top.left != null) queue.add(top.left); if(top.right != null) queue.add(top.right); if(count == nextCount)&#123; nextCount = queue.size(); // 更新下一层的个数 count =0； depth++; &#125; &#125; return depth; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后序遍历序列]]></title>
    <url>%2F2017%2F09%2F22%2Ftreenode-houxubianli%2F</url>
    <content type="text"><![CDATA[二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路：后续遍历：左右根 例如：arr = {3,4,2,1,5,6}根节点为 6, 后序遍历的最后一位既是根节点root 二叉搜索树的左子树均比root小 二叉搜索树的右子树均比root大 先找到根节点 确定左子树的长度，找到最后一个不大root的点 进行遍历 代码实现： import java.util.Arrays; public class Main{ public boolean VerifySequenceBST(int[] arr){ if(arr == null || arr.length == 0) return false; int len = arr.length; int root = arr[len-1]; // 根节点 int cut = 0; // 计算左子树的长度 // 确定左子树的长度 for(int i=0;i&lt;len-1;i++){ if(arr[i]&lt;root) cut = cut + 1 } // 如果cut=0,说明只有右子树,如果右子树中有小于root的点,返回false; if(cut == 0){ for(int j=0;j&lt;len-1;j++){ if(arr[j]&lt;root) return false; } }else{ VerifySequenceBST(Arrays.copyOfRange(arr,0,len-1)); } // 递归左子树 boolean left = true; if(cut &gt; 0) left = VerifySequenceBST(Arrays.copyOfRange(arr,0,cut)); // 递归右子树 boolean right = true; if(cut &lt; len-1) right = VerifySequenceBST(Arrays.copyOfRange(arr,cut,len-1)); return (left &amp;&amp; right); } }]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树中和为某一值得路径]]></title>
    <url>%2F2017%2F09%2F22%2Ftreenode-findpath%2F</url>
    <content type="text"><![CDATA[二叉树中和为某一值得路径题目描述输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 回溯法 代码实现： 123456789101112131415161718import java.util.ArrayList;public class Main&#123; private ArrayList&lt;Ingeter&gt; list = new ArrayList&lt;Integer&gt;(); private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode node,int target)&#123; if(node == null) return result; target = target-root.val; list.add(node.val); if(target == 0 &amp;&amp; node.left == null &amp;&amp; node.right == null)&#123; result.add(new ArrayList&lt;Integer&gt;(list)); &#125; FindPath(root.left,target); FindPath(root.right,target); list.remove(list.size()-1); return result; &#125;&#125; 剑指 offer 12345678910111213141516171819202122232425import java.util.Stack;public class Main&#123; public static void findPath(TreeNode root,int target)&#123; if(root == null) return; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int currentSum = 0; helper(root,target,stack,currentSum); &#125; public static void helper(TreeNode root,int target,Stack&lt;Integer&gt; stack,int currentSum)&#123; currentSum += root.value; stack.push(root.value); if(root.left == null &amp;&amp; root.right == null &amp;&amp; currentSum == target)&#123; for(int path: stack) System.out.print(path); System.out.println(); &#125; if(root.left != null) findPath(root.left,target,stack,currentSum); if(root.right != null) findPath(root.right,target,stack,currentSum); stack.pop() // 如果当前节点，没有左右分支，并且 currentSum != target ,弹出 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中倒数第k个节点]]></title>
    <url>%2F2017%2F09%2F21%2Flinklist-kth%2F</url>
    <content type="text"><![CDATA[链表中倒数第k个节点先找到整数的第k个节点，总长为 m ，剩余节点为 m-k再设置一个节点从头开始，当前节点从 m-k开始即可得出 倒数第二个 K 节点 代码实现 1234567891011121314151617181920212223public class Main&#123; public ListNode findKthListNode(ListNode head,int k)&#123; if(head == null || k == 0) return null; ListNode resultNode = null; ListNode headNode = head; for(int i=1;i&lt;k;i++)&#123; // 注意条件 if(headNode.next != null)&#123; headNode = headNode.next; &#125;else&#123; return null; &#125; &#125; resultNode = head; while(headNode.next != null)&#123; resultNode = resultNode.next; headNode = headNode.next; &#125; return resultNode; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2017%2F09%2F21%2FprintTailFromHead%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表1234567class ListNode&#123; int data; ListNode next = null; ListNode(int data)&#123; this.data = data; &#125;&#125; 非递归方式思路：利用 stack 先进后出的特点，先将链表压入栈中 12345678910111213141516import java.util.Stack;public class Main&#123; public static void printReverse(ListNode node)&#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); while(node != null)&#123; stack.push(node); node = node.next; &#125; while(!stack.isEmpty())&#123; System.out.println(stack.pop().data); &#125; &#125;&#125; 递归123456789public class Main&#123; public static void printReverse(ListNode node)&#123; if(node != null)&#123; if(node.next != null) printReverse(node.next); &#125; System.out.println(node.data); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【java算法】编程题1]]></title>
    <url>%2F2017%2F09%2F21%2Fjava-scores%2F</url>
    <content type="text"><![CDATA[题目要求整数数组scores中一次存放了学号1到100的100名学生的C语言考试成绩，要求写一个函数返回一个数组一次存放学号1到100的学生的C语言成绩排名名次。例如：scores={4,5,4,2} 则应返回数组{2,1,2,4}函数声明：int[] getRank(int[] scores); 代码实现： 123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] s = &#123;4,5,4,2,1&#125;; int[] result = getRank(s); for(int a:result)&#123; System.out.print(a); &#125; &#125; public static int[] getRank(int[] scores)&#123; int arr[] = new int[scores.length]; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;scores.length;i++)&#123; list.add(scores[i]); &#125; // 使用默认 sort() 是升序排序，重写sort方法，改成降序排序 Collections.sort(list,new Comparator&lt;Integer&gt;() &#123; //降序排序 public int compare(Integer o1,Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); for(int i=0;i&lt;scores.length;i++)&#123; if(list.contains(scores[i]))&#123; arr[i] = list.indexOf(scores[i])+1; &#125; &#125; return arr; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】集合类]]></title>
    <url>%2F2017%2F09%2F21%2Fjava-collection%2F</url>
    <content type="text"><![CDATA[Java Collection(集合类详解)Collection接口 派生 List 和 Set接口 Map 不属于 Collection Set接口 是Collection的子接口 不包含重复的元素 HashSet类和TreeSet类 一般先将元素添加到HashSet，再把集合转化为 TreeSet来进行有序遍历会更快。 为了优化 HashSet空间的使用，可以调整初试容量因子和负载因子。TreeSet不包含调优项，因为树总是平衡的。保证了插入、删除、查询的性能为 logn HashSet 和 TreeSet 都实现了Cloneable接口。 List 接口List接口继承了Collection接口来定义一个允许重复元素的集合。 List 接口提供了特殊的迭代器，称为ListIterator，除了允许Iterator接口提供正常操作外，该迭代器还允许元素插入和替换，以及双向访问。还提供了一个方法来获取从列表中指定位置开始的列表迭代器。 List subList(int fromIndex,int toIndex)处理 subList() 时，位于fromIndex的元素在子列表中，而位于toIndex的元素则不是。 Linked 改快读慢Array 读快改慢Hash 两者之间 Collection是集合接口 Set子接口：无序，不允许重复 List子接口：有序，可以有重复元素。 区别：Collections 是集合类 Set和List对比： Set:检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置的改变。 Set 和 List 具体类 Set： HashSet：以哈希表的形式存放元素，插入删除速度快。 List： ArrayList：动态数组 LinckedList：链表、队列和堆栈。 Array 和 java.util.VectorVector 是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。 Map 接口 Map接口不是Collection的接口的继承，而是从自己的用于维护键-值关联的接口层次入手的。按定义，该接口描述了从不重复的键到值得映射。 我们可以把这个接口方法分成三组操作：改变、查询和提供可选视图。 改变操作允许您从映射中添加和除去键-值对。键和值都可以为 null。但是，您不能把Map 作为一个键或值添加给自身。 Object put(Object key, Object value)返回值是被替换的值。 Object remove(Object key) void putAll(Map mapping) void clear() 查询操作允许您检查映射内容： Object get(Object key) boolean containsKey(Object key) boolean containsValue(Object value) int size() boolean isEmpty() 最后一组方法允许您把键或值的组作为集合来处理。 public Set keySet() public Collection values() public Set entrySet()因为映射中键的集合必须是唯一的，您用 Set 支持。因为映射中值的集合可能不唯一，您用Collection 支持。最后一个方法返回一个实现 Map.Entry 接口的元素 Set。 Map.Entry 接口Map 的 entrySet() 方法返回一个实现Map.Entry 接口的对象集合。集合中每个对象都是底层 Map 中一个特定的键-值对。通过这个集合迭代，您可以获得每一条目的键或值并对值进行更改。但是，如果底层 Map 在Map.Entry 接口的setValue() 方法外部被修改，此条目集就会变得无效，并导致迭代器行为未定义 HashMap 类和 TreeMap 类“集合框架”提供两种常规的 Map 实现：HashMap 和TreeMap。和所有的具体实现一样，使用哪种实现取决于您的特定需要。在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按顺序遍历键，那么TreeMap 会更好。根据集合大小，先把元素添加到 HashMap，再把这种映射转换成一个用于有序键遍历的 TreeMap 可能更快。使用HashMap 要求添加的键类明确定义了 hashCode() 实现。有了TreeMap 实现，添加到映射的元素一定是可排序的。我们将在排序中详细介绍。为了优化 HashMap 空间的使用，您可以调优初始容量和负载因子。这个TreeMap 没有调优选项，因为该树总处于平衡状态。HashMap 和 TreeMap 都实现Cloneable 接口。Hashtable 类和 Properties 类是Map 接口的历史实现。我们将在Dictionary 类、Hashtable 类和 Properties 类中讨论。 映射的使用示例以下程序演示了具体 Map 类的使用。该程序对自命令行传递的词进行频率计数。HashMap 起初用于数据存储。后来，映射被转换为TreeMap 以显示有序的键列列表。 12345678910111213141516171819202122import java.util.*;public class MapExample &#123; public static void main(String args[]) &#123; Map map = new HashMap(); Integer ONE = new Integer(1); for (int i=0, n=args.length; i&lt;n; i++) &#123; String key = args[i]; Integer frequency = (Integer)map.get(key); if (frequency == null) &#123; frequency = ONE; &#125; else &#123; int value = frequency.intValue(); frequency = new Integer(value + 1); &#125; map.put(key, frequency); &#125; System.out.println(map); Map sortedMap = new TreeMap(map); System.out.println(sortedMap); &#125;&#125; Java集合框架是最常被问到的Java面试问题，要理解Java技术强大特性就有必要掌握集合框架。这里有一些实用问题，常在核心Java面试中问到。 什么是Java集合API Java集合框架API是用来表示和操作集合的统一框架，它包含接口、实现类、以及帮助程序员完成一些编程的算法。简言之，API在上层完成以下几件事： 编程更加省力，提高城程序速度和代码质量 非关联的API提高互操作性 节省学习使用新API成本 节省设计新API的时间 * 鼓励、促进软件重用 具体来说，有6个集合接口，最基本的是Collection接口，由三个接口Set、List、SortedSet继承，另外两个接口是Map、SortedMap，这两个接口不继承Collection，表示映射而不是真正的集合。 什么是Iterator 一些集合类提供了内容遍历的功能，通过java.util.Iterator接口。这些接口允许遍历对象的集合。依次操作每个元素对象。当使用 Iterators时，在获得Iterator的时候包含一个集合快照。通常在遍历一个Iterator的时候不建议修改集合本省。 Iterator与ListIterator有什么区别？ Iterator：只能正向遍历集合，适用于获取移除元素。ListIerator：继承Iterator，可以双向列表的遍历，同样支持元素的修改。 什么是HaspMap和Map？ Map是接口，Java 集合框架中一部分，用于存储键值对，HashMap是用哈希算法实现Map的类。 HashMap与HashTable有什么区别？对比Hashtable VS HashMap 两者都是用key-value方式获取数据。Hashtable是原始集合类之一（也称作遗留类）。HashMap作为新集合框架的一部分在Java2的1.2版本中加入。它们之间有一下区别： HashMap和HashTable大致是等同的，除了非同步和空值（HashMap允许null值作为key和value，而Hashtable不可以）。 HashMap没法保证映射的顺序一直不变，但是作为HashMap的子类LinkedHashMap，如果想要预知的顺序迭代（默认按照插入顺序），你可以很轻易的置换为HashMap，如果使用Hashtable就没那么容易了。 HashMap不是同步的，而Hashtable是同步的。 迭代HashMap采用快速失败机制，而Hashtable不是，所以这是设计的考虑点。 在Hashtable上下文中同步是什么意思？ 同步意味着在一个时间点只能有一个线程可以修改哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其他线程等待锁的释放。 什么叫做快速失败特性 从高级别层次来说快速失败是一个系统或软件对于其故障做出的响应。一个快速失败系统设计用来即时报告可能会导致失败的任何故障情况，它通常用来停止正常的操作而不是尝试继续做可能有缺陷的工作。当有问题发生时，快速失败系统即时可见地发错错误告警。在Java中，快速失败与iterators有关。如果一个iterator在集合对象上创建了，其它线程欲“结构化”的修改该集合对象，并发修改异常 （ConcurrentModificationException） 抛出。 怎样使HashMap同步？ HashMap可以通过Map m = Collections.synchronizedMap（hashMap）来达到同步的效果。 什么时候使用Hashtable，什么时候使用HashMap 基本的不同点是Hashtable同步HashMap不是的，所以无论什么时候有多个线程访问相同实例的可能时，就应该使用Hashtable，反之使用HashMap。非线程安全的数据结构能带来更好的性能。 如果在将来有一种可能—你需要按顺序获得键值对的方案时，HashMap是一个很好的选择，因为有HashMap的一个子类 LinkedHashMap。所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用LinkedHashMap替换HashMap。反观要是使用的Hashtable就没那么简单了。同时如果有多个线程访问HashMap，Collections.synchronizedMap（）可以代替，总的来说HashMap更灵活。 为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector 你应该使用ArrayList而不是Vector是因为默认情况下你是非同步访问的，Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全（如果你迭代一个Vector，你还是要加锁，以避免其它线程在同一时刻改变集合）.而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。 事实上Vector结合了“可变数组”的集合和同步每个操作的实现。这是另外一个设计上的缺陷。Vector还有些遗留的方法在枚举和元素获取的方法，这些方法不同于List接口，如果这些方法在代码中程序员更趋向于想用它。尽管枚举速度更快，但是他们不能检查如果集合在迭代的时候修改了，这样将导致问题。尽管以上诸多原因，oracle也从没宣称过要废弃Vector。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】异常处理]]></title>
    <url>%2F2017%2F09%2F21%2Fjava-exception%2F</url>
    <content type="text"><![CDATA[Java 异常处理直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Test &#123; public TestException() &#123; &#125; boolean testEx() throws Exception &#123; boolean ret = true; try &#123; ret = testEx1(); &#125; catch (Exception e)&#123; System.out.println(&quot;testEx,catch exception&quot;); ret = false; throw e; &#125; finally &#123; System.out.println(&quot;testEx,finally;return value=&quot; + ret); return ret; &#125; &#125; boolean testEx1() throws Exception &#123; boolean ret = true; try &#123; ret = testEx2(); if(!ret) &#123; return false; &#125; System.out.println(&quot;testEx1,at the end of try&quot;); return ret; &#125; catch (Exception e)&#123; System.out.println(&quot;testEx1,catch exception&quot;); ret = false; throw e; &#125; finally&#123; System.out.println(&quot;testEx1,finally;return value=&quot; + ret); return ret; &#125; &#125; boolean testEx2() throws Exception &#123; boolean ret = true; try &#123; int b = 12; int c; for(int i=2;i&gt;=-2;i--)&#123; c = b/i; System.out.println(&quot;i=&quot; + i); &#125; return true; &#125;catch(Exception e) &#123; System.out.println(&quot;testEx2,catch exception&quot;); ret = false; throw e; &#125;finally &#123; System.out.println(&quot;testEx2,finally;return value=&quot; + ret); return ret; &#125; &#125; public static void main(String args[])&#123; Test test = new Test(); try&#123; test.testEx(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 输出:123456i=2i=1testEx2, catch exceptiontestEx2, finally; return value=falsetestEx1, finally; return value=falsetestEx, finally; return value=false java 异常异常指不期而至的各种状况，如：文件找不到，网络连接失败，非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java 通过 API中Throwable类的众多子类描述各种不同的异常。因此，Java 异常都是对象，是Throwable 子类的实例，描述了出现在一段编码中的错误的条件。当条件生成时，错误将引发异常。 Java 异常类层次结构图： Java 把所有的非正常情况分成两种：都继承自 Throwable 父类 异常(Exception) 错误(Error) Error错误：一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或者不可能捕获，将导致程序中断。通常应用无法处理这种错误，无法使用catch捕捉 Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。 Exception Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 RuntimeException RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ Error 和Exception一样，Error也是Throwable的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 和RuntimeException一样，编译器也不会检查Error。 Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。 (01) 运行时异常定义: RuntimeException及其子类都被称为运行时异常。特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ (02) 被检查的异常定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 被检查异常通常都是可以恢复的。 (03) 错误定义: Error类及其子类。特点: 和运行时异常一样，编译器也不会对错误进行检查。 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 按照Java惯例，我们是不应该是实现任何新的Error子类的！ 先捕获小异常，再捕获大异常 建议不要在finally 中使用return ，会覆盖掉 try或者catch中的return]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】快速排序]]></title>
    <url>%2F2017%2F09%2F20%2Fjava-sort-quick%2F</url>
    <content type="text"><![CDATA[快速排序在排序算法中，经常会问到 时间复杂度 和 空间复杂度 的问题，同时在排序算法算法中，经常会问到稳定性的问题。接下来介绍一下一些基本的概念： 排序算法的稳定性如果在对象序列中有两个对象r[i]和r[j] ,它们的排序码k[i]==k[j] 。如果排序前后,对象r[i]和r[j] 的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。 排序算法的评价时间开销 排序的时间开销可用算法执行中的数据比较次数与数据移动次数来衡量。 算法运行时间代价的大略估算一般都按平均情况进行估算。对于那些受对象排序码序列初始排列及对象个数影响较大的，需要按最好情况和最坏情况进行估算 空间开销 算法执行时所需要的附加存储。 快速排序的基本思想： 任选一个记录，以其关键字为“枢轴”，序列中比它小的移动到记录之前，反之移动到他的后面 通过一趟排序将待排的记录分隔成两个区域，一个区域中记录的关键字比另一个区域的关键字小(一次划分) 然后左右两边分别处理进行相同的操作直到排好 快排复杂度： 平均时间复杂度O(nlogn) 不稳定 代码实现： 1234567891011121314151617181920212223242526272829303132333435public class QuickSort&#123; public static void main(String args[])&#123; int[] arr = &#123;5,2,8,6,4,3,1,9&#125;; quick(arr,0,arr.length-1); for(int a:arr)&#123; System.out.println(a + &quot; &quot;); &#125; &#125; public static void quick(int[] arr,int low,int high)&#123; while(low&lt;high)&#123; int middle = quickSoring(arr,low,high); quickSorting(arr,low,middle-1); quickSorting(arr,middle+1,high); &#125; &#125; public static int quickSorting(int[] arr,int low,int high)&#123; // 选择起始点作为中轴点 int temp = arr[low]; while(low&lt;high)&#123; // 找到小于中轴点的点 while(low &lt; high &amp;&amp; arr[high] &gt; temp) high--; arr[low] = arr[high]; // 找到大于中轴点的点 while(low &lt; high &amp;&amp; arr[low] &lt; temp) low++; arr[high] = arr[low]; &#125; arr[low] = temp; return low; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】插入排序]]></title>
    <url>%2F2017%2F09%2F20%2Fjava-sort-insert%2F</url>
    <content type="text"><![CDATA[插入排序出入排序类似于 整扑克牌 例如： [2,5,3,6,8,1] 第一遍 2 5 3 6 8 1 第二遍 2 3 5 6 8 1 第三遍 2 3 5 6 8 1 … 第5遍1 2 3 4 5 8 复杂度：空间复杂度 O(1) 时间复杂度最好 O(n) 最坏 O(n^2) 平均 O(n^2) 最差情况：反序,需要移动 n*(n-1)/2 个元素最好情况：正序,不需要移动元素 稳定排序代码实现： 123456789101112131415161718public class Main&#123; public static void main(String args[])&#123; int[] arr = &#123;6,5,8,3,2,1&#125;; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;=0;j--)&#123; // 注意边界条件 j ;如果 j&gt;=0, 判断arr[j+1] arr[j];j&gt;0 判断arr[j-1] arr[j] if(arr[j+1]&lt;arr[j])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for(int a:arr)&#123; System.out.print(a); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】选择排序]]></title>
    <url>%2F2017%2F09%2F20%2Fjava-sort-select%2F</url>
    <content type="text"><![CDATA[选择排序原理：每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，知道全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。 简单选择排序的基本思想：给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arrr[1]交换；第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与r[2]交换；以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。 举例：数组 int[] arr={5,2,8,4,9,1}; 第一趟排序： 原始数据：5 2 8 4 9 1 最小数据1，把1放在首位，也就是1和5互换位置， 排序结果：1 2 8 4 9 5 第二趟排序： 第1以外的数据{2 8 4 9 5}进行比较，2最小， 排序结果：1 2 8 4 9 5 第三趟排序： 除1、2以外的数据{8 4 9 5}进行比较，4最小，8和4交换 排序结果：1 2 4 8 9 5 第四趟排序： 除第1、2、4以外的其他数据{8 9 5}进行比较，5最小，8和5交换 排序结果：1 2 4 5 9 8 第五趟排序： 除第1、2、4、5以外的其他数据{9 8}进行比较，8最小，8和9交换 排序结果：1 2 4 5 8 9 注：每一趟排序获得最小数的方法：for循环进行比较，定义一个第三个变量temp，首先前两个数比较，把较小的数放在temp中，然后用temp再去跟剩下的数据比较，如果出现比temp小的数据，就用它代替temp中原有的数据。具体参照后面的代码示例 选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) / 2。复杂度：O(n^2) 不稳定 123456789101112131415161718192021222324public class Main&#123; public static void main(String args[])&#123; int[] arr = &#123;3,1,5,2,9,6,8&#125;; // 选择排序优化 for(int i=0;i&lt;arr.length;i++)&#123; // 第i趟排序 int k = i; for(int j = k+1;j&lt;arr.length;j++)&#123; // 选最小的记录 if(arr[j]&lt;arr[k]) k = j; // 记录目前找到的最小值所在的位置 &#125; // 内循环结束，找到最小的值,再进行交换 if(k&gt;i)&#123; int temp = arr[k]; arr[k] = arr[i]; arr[i] = temp; &#125; &#125; for(int a:arr)&#123; System.out.print(a); &#125; &#125;&#125; 输出： 1235689 为什么选择排序不是稳定排序？选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】冒泡排序]]></title>
    <url>%2F2017%2F09%2F20%2Fjava-sort-bubble%2F</url>
    <content type="text"><![CDATA[冒泡排序原理：比较两个相邻的元素，将值大的元素交换至右端 思路：依次比较相邻的两个数，将较小的数放在前面，大数放在后面。也就是，首先比较第1 和第2 个数，将小数放在前面，大数放在后。然后比较 2，3。直至全部排序完成。 举例说明：要排序数组：int[] arr={6,3,8,2,9,1}; 第一趟排序： 第一次排序：6和3比较，6大于3，交换位置： 3 6 8 2 9 1 第二次排序：6和8比较，6小于8，不交换位置：3 6 8 2 9 1 第三次排序：8和2比较，8大于2，交换位置： 3 6 2 8 9 1 第四次排序：8和9比较，8小于9，不交换位置：3 6 2 8 9 1 第五次排序：9和1比较：9大于1，交换位置： 3 6 2 8 1 9 第一趟总共进行了5次比较， 排序结果： 3 6 2 8 1 9 第二趟排序： 第一次排序：3和6比较，3小于6，不交换位置：3 6 2 8 1 9 第二次排序：6和2比较，6大于2，交换位置： 3 2 6 8 1 9 第三次排序：6和8比较，6大于8，不交换位置：3 2 6 8 1 9 第四次排序：8和1比较，8大于1，交换位置： 3 2 6 1 8 9 第二趟总共进行了4次比较， 排序结果： 3 2 6 1 8 9 第三趟排序： 第一次排序：3和2比较，3大于2，交换位置： 2 3 6 1 8 9 第二次排序：3和6比较，3小于6，不交换位置：2 3 6 1 8 9 第三次排序：6和1比较，6大于1，交换位置： 2 3 1 6 8 9 第二趟总共进行了3次比较， 排序结果： 2 3 1 6 8 9 第四趟排序： 第一次排序：2和3比较，2小于3，不交换位置：2 3 1 6 8 9 第二次排序：3和1比较，3大于1，交换位置： 2 1 3 6 8 9 第二趟总共进行了2次比较， 排序结果： 2 1 3 6 8 9 第五趟排序： 第一次排序：2和1比较，2大于1，交换位置： 1 2 3 6 8 9 第二趟总共进行了1次比较， 排序结果： 1 2 3 6 8 9 最终结果：1 2 3 6 8 9 由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即 1234567for(int i=1;i&lt;arr.length;i++)&#123; // 注意条件，&lt; 和 &lt;= 的条件 for(int j=1;j&lt;arr.length-i;j++)&#123; //交换位置&#125; 用时间复杂度来说： 如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数和记录移动次数均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。 如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： 冒泡排序的最坏时间复杂度为：O(n2) 。 综上所述：冒泡排序总的平均时间复杂度为：O(n2) 。 复杂度： 最好O(n) 平均O(n2) 最坏O(n2) 稳定排序 代码实现： 1234567891011121314151617public class Main&#123; public static void main(String args[])&#123; int[] arr = &#123;3,2,1,4,5,7,3&#125;; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j+1]&lt;=arr[j])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for(int i:arr)&#123; System.out.print(i + &quot; &quot;); &#125; &#125;&#125; 输出：1 2 3 3 4 5 7]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【查找算法】二分查找]]></title>
    <url>%2F2017%2F09%2F20%2Fjava-suanfa-erfenfa%2F</url>
    <content type="text"><![CDATA[二分法查找在昨天的面试中，考了二分法查找，今天好好整理一下二分法查找 二分法查找原始版-查找某个元素的下标(任意一个)复杂度：总共有N个元素，每次查找的区间大小就是N,N/2，N/4…N/2^k k是循环的次数由于N/2^k 取整后 &gt;= 1,也就是 N/2^k = 1; k = log2n时间复杂度是: O(logn) 1234567891011121314151617181920212223class Test&#123; public static void main(String args[])&#123; int[] a = &#123;1,2,3,4&#125;; int result = binarySearch(a,2); System.out.prinltn(result); &#125; public static int binarySearch(int[] arr,int k)&#123; int low = 0; int high = arr.length-1; // 注意这里的-1 int mid = 0; while(low&lt;=high)&#123; // 注意终止的条件,如果 low&lt;high 会陷入死循环 &#123;1,2,3,4,5&#125; 当查找 5 时，只有low等于 high 时才终止。 mid = (high + low)&gt;&gt;1; if(arr[mid] == k) return mid; else if(arr[mid] &gt; k) high = mid - 1; else if(arr[mid] &lt; k) low = mid + 1; &#125; return -1; &#125;&#125; 二分法查找第一个大于等于某个数的下标12345678910111213141516171819202122public class Main&#123; public static void main(String args[])&#123; int[] arr = &#123;1,1,2,3,5&#125;; int result = FirstGreatOrEqual(arr,4,3); System.out.println(result); &#125; public static int FirstGreatOrEqual(int[] a,int n,int k)&#123; int low = 0; int mid = 0; int high = n; while(low&lt;=high)&#123; //注意终止条件 mid = low + ((high-low) &gt;&gt; 1); if(a[mid] &gt;= k) high = mid - 1; else low = mid + 1; &#125; return low &lt;= n ? low:-1; &#125;&#125; 查找第一个大于某个数的下标1234567891011121314151617181920public class Main&#123; public static void main(String args[])&#123; int[] arr = &#123;1,2,3,4,5,5&#125;; int result = FirstGreat(arr,arr.length-1,3); System.out.println(result); &#125; public static int FirstGreat(int arr,int n,int k)&#123; int low = 0; int high = n; int mid = 0; while(low&lt;=high)&#123; mid = low + ((high-low) &gt;&gt; 1); if(arr[mid]&gt;k) high = mid -1; else low = mid -1; &#125; return low &lt;= n ? low : -1; &#125;&#125; 查找数组中某个数的位置的最小下标，没有返回-1123456789101112131415161718192021public class Mian&#123; public static void main(String args[])&#123; int[] arr = &#123;1,2,3,4,4,5&#125;; int result = FirstIndex(arr,arr.length-1,3); System.out.println(result); &#125; public static int FirstIndex(int[] a,int n,int k)&#123; int low = 0; int high = n; int mid = 0; while(low&lt;=high)&#123; mid = low + ((high-low)&gt;&gt;1); if(a[mid]&gt;=k) high = mid -1; else low = mid + 1; &#125; return (low&lt;=n) &amp;&amp; (a[low] == k) ? low:-1; &#125;&#125; 查找数组中某个数的位置的最大下标，没有返回-1123456789101112131415161718192021public class Mian&#123; public static void main(String args[])&#123; int[] arr = &#123;1,2,3,4,4,5&#125;; int result = FirstIndex(arr,arr.length-1,3); System.out.println(result); &#125; public static int lastIndex(int[] a,int n,int k)&#123; int low = 0; int high = n; int mid = 0; while(low&lt;=high)&#123; mid = low + ((high-low)&gt;&gt;1); if(a[mid]&gt;k) high = mid -1; else low = mid + 1; &#125; return (low&lt;=n) &amp;&amp; (a[low-1] == k) ? low-1:-1; &#125;&#125; 查找数组中小于某个数的最大下标，没有返回-1123456789101112131415public int firstLess(int[] a, int n, int key) &#123; // n + 1 个数 int low = 0; int high = n; int mid = 0; while (low &lt;= high) &#123; mid = low + ((high - low) &gt;&gt; 1); if (key &lt;= a[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return (low - 1 &gt;= 0) ? low - 1 : -1; &#125; 查找数组中某个数的出现次数1234567891011121314151617181920212223242526272829303132333435363738public int getCount(int[] a, int n, int key) &#123; // n + 1 个数 int first = firstGreatOrEqual2(a, n, key); int last = firstGreat2(a, n, key); return last - first; &#125; public int firstGreatOrEqual2(int[] a, int n, int key) &#123; // n + 1 个数 int low = 0; int high = n; int mid = 0; while (low &lt;= high) &#123; mid = low + ((high - low) &gt;&gt; 1); if (key &lt;= a[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return low; &#125; public int firstGreat2(int[] a, int n, int key) &#123; // n + 1 个数 int low = 0; int high = n; int mid = 0; while (low &lt;= high) &#123; mid = low + ((high - low) &gt;&gt; 1); if (key &lt; a[mid]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return low; &#125; 喝水不忘挖井人二分算法]]></content>
      <categories>
        <category>算法</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】多线程]]></title>
    <url>%2F2017%2F09%2F19%2Fthread%2F</url>
    <content type="text"><![CDATA[Java线程进程和线程的区别进程是操作系统的调用程序，拥有独立的系统资源。线程是进程的自己，它不是拥有系统的资源，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间。而所有的线程共享一片相同的内存空间。每个线程都有独立的栈内存来存储本地数据。 线程的基本概念、基本状态和状态之间的关系线程状态之间的关系 线程的五种状态 新建： 使用 new 关键字新建一个线程。如： Thread t = new MyThread() 就绪： 线程对象调用了 start() 方法后；此时线程没有开始执行，只是表示可以开始运行了。 t.start() 运行： 线程获得CPU,开始执行 run() 方法。 阻塞： 在某些情况下，如执行 sleep() 方法，等待 I/O设备等资源，将让出CPU暂时停止自己的运行。 等待阻塞：运行状态中的线程执行wait() 方法，使本线程进入到等待阻塞状态 同步阻塞：线程在获取synchronized同步锁失败(因为锁被其他线程所占用)，他会进入同步阻塞状态 其他阻塞：通过调用线程的sleep()或join()或发出I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡： run() 方法执行结束，线程正常结束，或调用 stop() 方法强制终止该线程。 线程方法 join(): 调用哪个线程的 join() 方法，就等待哪个线程执行完毕后调用者在继续执行。 yield(): 暂停正在执行的线程，但是不会阻塞该线程，只是将其转入就绪状态，有可能暂时之后马上又继续执行， 是静态方法。（就绪） sleep(): 将正执行的线程暂停一段时间，不释放锁，常用语倒计时和模拟网络延时，静态方法。（阻塞） setDaemon(true): 设置为后台线程；如果所有的前台线程死亡，后台线程会自动死亡。 Thread.currentThread(): 获取当前线程 getName(): 获取线程名称 setName(): 设置线程名称 Java线程的创建及启动Java中线程的创建常见的有三种基本形式 继承Thread类，重写该类的run()方法 实现Runnable接口，并重写该接口的run方法，该run()方法同样是线程执行体。创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正 的Thread对象。 使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现call()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 继承Thread类1234567891011121314151617181920212223class MyThread extends Thread&#123; private int i = 0; @override public void run()&#123; for(i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName() + &quot;&quot; + i); &#125; &#125;&#125;public class Test&#123; public static void main(String args[])&#123; for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName() + &quot;&quot; + i); if(i == 30)&#123; Thread myThread1 = new MyThread(); Thread myThread2 = new MyThread(); myThread1.start(); myThread2.start(); &#125; &#125; &#125;&#125; 实现Runnable接口123456789101112131415161718192021222324class MyRunnable implements Runnable&#123; private int i = 0; @override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125;&#125;public class Test&#123; public static void main(String args[])【 for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName() + &quot;&quot; + i); if(i == 30)&#123; Runnable myRannable = new MyRunnable(); Thread thread1 = new Thread(myRunnable); Thread thread2 = new Thread(myRunnable); thread1.start(); thread2.start(); &#125; &#125; &#125;&#125; 使用Callable和Future接口创建线程123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThreadTest &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30) &#123; Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程 thread.start(); //线程进入到就绪状态 &#125; &#125; System.out.println(&quot;主线程for循环执行完毕..&quot;); try &#123; int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果 System.out.println(&quot;sum = &quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; private int i = 0; // 与run()方法不同的是，call()方法具有返回值 @Override public Integer call() &#123; int sum = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); sum += i; &#125; return sum; &#125;&#125; 不能对同一线程对象两次调用start()方法。 Java 多线程的就绪、运行和死亡状态 就绪状态转换为死亡状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或运行过程中失去处理器资源 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如： 1234567891011121314151617181920212223242526272829303132333435public class ThreadTest &#123; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30) &#123; thread.start(); &#125; if(i == 40)&#123; myRunnable.stopThread(); &#125; &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private boolean stop; @Override public void run() &#123; for (int i = 0; i &lt; 100 &amp;&amp; !stop; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125; public void stopThread() &#123; this.stop = true; &#125;&#125; Java 多线程的阻塞状态与线程控制Join()join —— 让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完为止，A才能得以继续执行。 123456789101112131415161718192021222324252627282930public class ThreadTest &#123; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30) &#123; thread.start(); try &#123; thread.join(); // main线程需要等待thread线程执行完后才能继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125;&#125; sleep()sleep —— 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，处于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。 前面有讲到，当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(1)即可。 123456789101112131415161718192021222324252627282930public class ThreadTest &#123; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30) &#123; thread.start(); try &#123; Thread.sleep(1); // 使得thread必然能够马上得以执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125;&#125; 注：睡一个毫秒级够了，因为CPU不会空闲，会切换到新建的线程。 后台线程概念/目的：后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。 生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用…伟大啊 ! !)。 设置后台线程：调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程。 1234567891011121314151617181920212223242526272829public class ThreadTest &#123; public static void main(String[] args) &#123; Thread myThread = new MyThread(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main thread i = &quot; + i); if (i == 20) &#123; myThread.setDaemon(true); myThread.start(); &#125; &#125; &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;i = &quot; + i); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 判断线程是否是后台线程：调用thread对象的isDeamon()方法。 注：main线程默认是前台线程，前台线程创建中创建的子线程默认是前台线程，后台线程中创建的线程默认是后台线程。调用setDeamon(true)方法将前台线程设置为后台线程时，需要在start()方法调用之前。前天线程都死亡后，JVM通知后台线程死亡，但从接收指令到作出响应，需要一定的时间。 改变线程的优先级 setPriority()每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。 设置线程优先级：setPriority(int priorityLevel)。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值： MAX_PRIORITY:10 MIN_PRIORITY:1 NORM_PRIORITY:5 获取线程优先级：getPriority()。 注：具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 1234567891011121314151617181920212223public class ThreadTest &#123; public static void main(String[] args) &#123; Thread myThread = new MyThread(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main thread i = &quot; + i); if (i == 20) &#123; myThread.setPriority(Thread.MAX_PRIORITY); myThread.start(); &#125; &#125; &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;i = &quot; + i); &#125; &#125;&#125; 线程让步：yield()yield()方法还与线程优先级有关，当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。 123456789101112131415161718192021222324252627282930313233343536public class ThreadTest &#123; public static void main(String[] args) &#123; Thread myThread1 = new MyThread1(); Thread myThread2 = new MyThread2(); myThread1.setPriority(Thread.MAX_PRIORITY); myThread2.setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;main thread i = &quot; + i); if (i == 20) &#123; myThread1.start(); myThread2.start(); Thread.yield(); &#125; &#125; &#125;&#125;class MyThread1 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;myThread 1 -- i = &quot; + i); &#125; &#125;&#125;class MyThread2 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;myThread 2 -- i = &quot; + i); &#125; &#125;&#125; 线程安全12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ThreadTest&#123; public static void main(String args[])&#123; Account account = new Account(&quot;111111&quot;,1000); DrawMoneyRunnable dmRunnable = new DrawMoneyRunnable(account,700); Thread thread1 = new Thread(dmRunnable); Thread thread2 = new Thread(dmRunnable); thread1.start(); thread2.start(); &#125;&#125;class DrawMoneyRunnable implements Runnable&#123; private Account account; private double drawAmount; public DrawMoneyRunnable(Account account,double drawAmount)&#123; super(); this.account = account; this.drawAmount = drawAmount; &#125; public void run()&#123; if(account.getBalance() &gt;= drawAmount)&#123; System.out.println(&quot;取钱成功，取钱数为:&quot; + drawAmount); double balance = account.getBalance() - drawAmount; account.setBalance(balance); System.out.println(&quot;余额为:&quot; + balance); &#125; &#125;&#125;class Account &#123; private String accountNo; private double balance; public Account()&#123; &#125; public Account(String accountNo,double balance)&#123; this.accountNo = accountNo; this.balance = balance; &#125; public String getAccountNo() &#123; return accountNo; &#125; public void setAccountNo(String accountNo) &#123; this.accountNo = accountNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125;&#125; 上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为： 12341 取钱成功， 取出钱数为：700.02 余额为：300.03 取钱成功， 取出钱数为：700.04 余额为：-400.0 也就是说，对于一张只有1000余额的银行卡，你们一共可以取出1400，这显然是有问题的。 经过分析，问题在于Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换，因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。此时，就会出现上述结果。 因此，讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。 同步方法对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推… 在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。12345public synchronized void run() &#123; // .... &#125; 同步代码块正如上面所分析的那样，解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。 同步代码块的格式为： 123synchroized(obj) &#123; //...&#125; 其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。 如上例中，最好选用account对象作为锁对象。（当然，选用this也是可以的，那是因为创建线程使用了runnable方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…） Lock对象同步锁上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。 使用Lock对象同步锁可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为：class x{ private final Lock lock = new ReentrantLock(); private void m(){ // 加锁 lock.lock(); // ... 需要进行线程安全同步的代码 // 释放锁 lock.unlock(); } } wait()/notify()/notifyAll() 线程通信实际上都是Object类中的本地方法。因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。 wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。 notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class ThreadTest&#123; public static void main(String args[])&#123; Account account = new Account(&quot;123456&quot;,0); Thread drawMoneyThread = new DrawMoneyThread(&quot;取钱线程&quot;,account,700); Thread depositeMoneyThread = new DepositeMonetThread(&quot;存钱线程&quot;,account,700); drawMoneyThread.start(); depositeMoneyThread.start(); &#125;&#125;// 线程class DrawMoneyThread extends Thread&#123; private Account account; private double amount; DrawMoneyThread(String threadName,Account account,double amount)&#123; super(threadName); this.account = account; this.amount = amount; &#125; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; account.draw(amount,i); &#125; &#125;&#125;class DepositeMoneyThread extends Thread&#123; private Account account; private double amount; public DepositeMoneyThread(String threadName,Account account,double amount)&#123; super(threadName); this.account = account; this.amount = amount; &#125; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; account.deposite(amount,i); &#125; &#125;&#125;class Account&#123; private String accountNo; private double balance; // 标记账户中是否已有存款 private boolean flag = false; public Accoutn()&#123; &#125; public Account(String accountNo,double balance)&#123; this.accountNo = accountNo; this.balance = balance; &#125; public String getAccountNo()&#123; return accountNo; &#125; public void setAccountNo(String accountNo) &#123; this.accountNo = accountNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; /** * 存钱 * * @param depositeAmount */ public synchronized void deposite(double depositeAmount, int i) &#123; if (flag) &#123; // 账户中已有人存钱进去，此时当前线程需要等待阻塞 try &#123; System.out.println(Thread.currentThread().getName() + &quot; 开始要执行wait操作&quot; + &quot; -- i=&quot; + i); wait(); // 1 System.out.println(Thread.currentThread().getName() + &quot; 执行了wait操作&quot; + &quot; -- i=&quot; + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; // 开始存钱 System.out.println(Thread.currentThread().getName() + &quot; 存款:&quot; + depositeAmount + &quot; -- i=&quot; + i); setBalance(balance + depositeAmount); flag = true; // 唤醒其他线程 notifyAll(); // 2 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;-- 存钱 -- 执行完毕&quot; + &quot; -- i=&quot; + i); &#125; &#125; /** * 取钱 * * @param drawAmount */ public synchronized void draw(double drawAmount, int i) &#123; if (!flag) &#123; // 账户中还没人存钱进去，此时当前线程需要等待阻塞 try &#123; System.out.println(Thread.currentThread().getName() + &quot; 开始要执行wait操作&quot; + &quot; 执行了wait操作&quot; + &quot; -- i=&quot; + i); wait(); System.out.println(Thread.currentThread().getName() + &quot; 执行了wait操作&quot; + &quot; 执行了wait操作&quot; + &quot; -- i=&quot; + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; // 开始取钱 System.out.println(Thread.currentThread().getName() + &quot; 取钱：&quot; + drawAmount + &quot; -- i=&quot; + i); setBalance(getBalance() - drawAmount); flag = false; // 唤醒其他线程 notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;-- 取钱 -- 执行完毕&quot; + &quot; -- i=&quot; + i); // 3 &#125; &#125;&#125; 上面的例子演示了wait()/notify()/notifyAll()的用法。部分输出结果为： 1234567891011121314151617181920212223242526272829303132取钱线程 开始要执行wait操作 执行了wait操作 -- i=0存钱线程 存款:700.0 -- i=0存钱线程-- 存钱 -- 执行完毕 -- i=0存钱线程 开始要执行wait操作 -- i=1取钱线程 执行了wait操作 执行了wait操作 -- i=0取钱线程 取钱：700.0 -- i=1取钱线程-- 取钱 -- 执行完毕 -- i=1取钱线程 开始要执行wait操作 执行了wait操作 -- i=2存钱线程 执行了wait操作 -- i=1存钱线程 存款:700.0 -- i=2存钱线程-- 存钱 -- 执行完毕 -- i=2取钱线程 执行了wait操作 执行了wait操作 -- i=2取钱线程 取钱：700.0 -- i=3取钱线程-- 取钱 -- 执行完毕 -- i=3取钱线程 开始要执行wait操作 执行了wait操作 -- i=4存钱线程 存款:700.0 -- i=3存钱线程-- 存钱 -- 执行完毕 -- i=3存钱线程 开始要执行wait操作 -- i=4取钱线程 执行了wait操作 执行了wait操作 -- i=4取钱线程 取钱：700.0 -- i=5取钱线程-- 取钱 -- 执行完毕 -- i=5取钱线程 开始要执行wait操作 执行了wait操作 -- i=6存钱线程 执行了wait操作 -- i=4存钱线程 存款:700.0 -- i=5存钱线程-- 存钱 -- 执行完毕 -- i=5存钱线程 开始要执行wait操作 -- i=6取钱线程 执行了wait操作 执行了wait操作 -- i=6取钱线程 取钱：700.0 -- i=7取钱线程-- 取钱 -- 执行完毕 -- i=7取钱线程 开始要执行wait操作 执行了wait操作 -- i=8存钱线程 执行了wait操作 -- i=6存钱线程 存款:700.0 -- i=7 由此，我们需要注意如下几点： 1.wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； 2.notify()/notifyAll()方法执行后，将唤醒此同步锁对象上的（任意一个-notify()/所有-notifyAll()）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果notify()/notifyAll()后面还有代码，还会继续进行，知道当前线程执行完毕才会释放同步锁对象； 3.notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2； 4.wait()/notify()/nitifyAll()完成线程间的通信或协作都是基于不同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系； 5.当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。 当然，上面的例子相对来说比较简单，只是为了简单示例wait()/notify()/noitifyAll()方法的用法，但其本质上说，已经是一个简单的生产者-消费者模式了。]]></content>
      <categories>
        <category>java</category>
        <category>线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从上到下打印二叉树]]></title>
    <url>%2F2017%2F09%2F18%2Fnodetree-reconstruct%2F</url>
    <content type="text"><![CDATA[从上到下打印二叉树12345678class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode(int val)&#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList; import java.util.LinkedList; import java.util.Queue; /** * * @comments 层次遍历二叉树 * 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 * 访问根节点，并将根节点入队。 * 当队列不空的时候，重复以下操作。 * 1、弹出一个元素。作为当前的根节点。 * 2、如果根节点有左孩子，访问左孩子，并将左孩子入队。 * 3、如果根节点有右孩子，访问右孩子，并将右孩子入队。 */ public class Solution&#123; public ArrayList&lt;Integer&gt; PrintFromToBottom(TreeNode root)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 存储值 Queue&lt;TreeNode&gt; queue = new Queue&lt;TreeNode&gt;(); list.add(root.val); queue.add(root); while(queue.size() != 0)&#123; root = queue.poll(); if(root.left != null)&#123; queue.add(root.left); list.add(root.left.val); &#125; if(root.right != null)&#123; queue.add(root.right); list.add(root.right.val); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[垂直搜索]]></title>
    <url>%2F2017%2F09%2F13%2Ffocused-crawler%2F</url>
    <content type="text"><![CDATA[垂直搜索Focused crawling enhanced by CBP-SLC(Content Block Partition-Selective Link Context)摘要复杂的网络环境和多种主题网页影响主题爬虫的效率。 网页： 锚文本 和 文本内容 基于以上：提出 启发性的方法 CBP-SLC 结合 网页的区分算法和选择性的使用网页相关块的一部分，提高主题爬虫的效率 为了引导爬虫，建立一个权重选举分类器 使用基于新颖的 TFIDF特征加权 的 SVM 算法分类的过程中， 1-DNF算法，(1-DNFC):从没有标记的数据集中分辨出可靠的不相关的页面 比较算法：Breadth-First Best-First Anchor Text Link context SLC CBP 标准：Harvest rate 收获率Target recall 召回率 Introduction原因：由于互联网的快速发展，网络上拥有大量的信息，人们要想找到有用的信息，变得越来越**困难。 主题爬虫：用来收集特定主题的网页，主题爬虫决定去浏览哪个网页基于当前的网页 主题爬虫的关键: 搜索策略 一般关于主题的 文本和链接总是在网页的同一块区域中， 所以 把网页分成多个文本块，而不是把整个页面当成一个整体。 锚文本是网页中的一个关键。 获取不相关页面的训练集是困难的，但是获取相关页面的训练集是效率很高的策略。 文本分类器 用来给新的网页打标签（是否相关） 本文使用的是 TFIDF 改进版 —》 TFIPNDF(Term frrquency Inverse Positive-Negative Document Frequency)计算 某词在 相关训练集和不相关训练集中的词权重。 CBP-SLC本文使用 Content Block Partition(CBP）算法 将网页分成 多个文本块。 如果一个高度相关的文本区域，在一个低相关性的网页中，将不会被 进行抓取。在一个不相关的网页中，但是他的 某块区域 相关性很强，说明 可以进行抓取。 在本文中，如果一个文本区域是相关的，爬虫将会对文本区域中的链接进行采集，否则，主题爬虫将将选择性的使用 link-context(SLC）来扩展区域 根据向光性。 Content block partition在不相关的网页中，可能很多的区域是相关的。 把多主题的网页分解成多个单主题的小区域，可以有效提高主题爬虫的搜索效率。]]></content>
      <categories>
        <category>垂直搜索</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【java基础】JVM 内存分区]]></title>
    <url>%2F2017%2F09%2F13%2Fjvm-face%2F</url>
    <content type="text"><![CDATA[JVM 虚拟机JVM 内存分哪几个区java虚拟机主要分为以下几个区： 方法区： 有时候也成为永久代，在该区很少发生垃圾回收，但是并不代表不发生GC，在这里进行GC主要是对方法区里的常量池和对类型的卸载。 方法区主要是用来存储已被虚拟机加载的类的信息、常量、静态变量、和即时编辑器编译后的代码等数据。 该区域是被线程共享的。 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。 虚拟机栈 虚拟机栈也就是我们平常所说的栈内存，它为java方法服务，每个方法在执行的时候都会常见一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 虚拟机是线程私有的，他的生命周期与线程相同。 局部变量表里存储的是基本数据类型、return Address类型(指向一条字节码指令的地址)和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者对象相关联的位置。局部变量所需的内存空间在编译器期间确定。 操作数帧的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式。 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接，动态链接就是将常量池中的符号引用在运行期转化为直接引用。 本地方法栈 本地方法栈和虚拟方法栈类似，只不过本地方法栈为Native方法服务。 堆 java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。 程序计数器 内存空间小，字节码解释器工作时通过改变这个技术支持可以选取下一条需要执行的字节码指令，分支循环、跳转、异常处理和线程回复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。 如何判断一个对象时候存活？(或者GC对象的判定方法)判断一个对象是否存活有两种方法： 引用计数法： 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为0时，说明此对象没有被引用，也就是“死对象”，将会被垃圾回收。 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B,对象B又引用着对象A，那么此时A，B对象的应用计数器都不为0，也就无法完成垃圾回收，所以主流的虚拟机都没有采用这种方法。。 可达性算法(引用链法) 该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。在java中可以作为GC Roots的对象有一下几种： 虚拟机栈中应用的对象 方法区类静态属性引用的对象 方法区常量池引用的对象 本地方法栈JNI引用的对象 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象不一定会被回收。当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记，如果对象在可达性分析中没有GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件就是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没有必要的。 如果该对象有必要执行finalize()方法，那么这个对象就会放在一个称为F-Queue的队列中，虚拟机就会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待他运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对出于F-Queue中的对象进行第二次被标记，这时，该对象将被移除“即将回收”集合，等待回收。 简述java垃圾回收机制在java中，程序员是不需要显示的去释放一个对象的内存的，而是虚拟机自行执行。在JVM中，有一个垃圾回收线程，他是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将他们添加到要回收的集合中，进行回收。 java 中垃圾收集的方法有哪些？ 标记-清除： 这是垃圾回收算法中最基础的，思想就是标记哪些要被回收的对象，然后统一回收。问题：效率不高，标记和清除的效率都很低；会产生大量的不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前出发一次GC动作。 复制算法： 年轻代分为Eden区和两个Survivor区，其中所有新创建的对象都在Eden区，当Eden区满后会出发minor GC将Eden区仍然存活的对象复制到其中一个Survivor区中，另外一个Survivor区中存活的对象也复制到这个Survivor中，以保证最终有一个Survivor区是空的。 标记-整理 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候，先将可回收的对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 分代收集 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代，在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记整理或者标记清除。]]></content>
      <categories>
        <category>java</category>
        <category>JVM 虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC 原理]]></title>
    <url>%2F2017%2F09%2F12%2Fspring-ioc%2F</url>
    <content type="text"><![CDATA[Spring IOC 原理IOC 简介 IOC 就是应用本身不依赖对象的创建和维护而是交给外部容器（spring），就是把应用和对象之间解耦，控制权交给外部容器。 IOC控制反转：说的是创建对象实例的控制权从代码控制玻璃到IOC容器控制，实际上就是我们现在说的第三方，侧重于原理。 DI依赖注入：说的是创建对象实例时，为这个对象注入属性值，或其他对象实例，侧重于实现。 注入方式 构造函数注入 1234567891011121314151617public class Team&#123; private Leader leader; public Team(Leader leader)&#123; this.leader = leader; &#125; public void firstMetting()&#123; leader.introduce(); &#125;&#125;public class Boss&#123; public void direct()&#123; Leader leader = new Li(); Team team = new Team(leader); team.firstMetting(); &#125;&#125; 属性注入 123456789101112131415161718public class Team&#123; private Leader leader; public SetLeader(Leader leader)&#123; this.leader = leader; &#125; public void firstMetting()&#123; leader.introduce(); &#125;&#125;public class Boss&#123; public void direct()&#123; Leader leader = new Li(); Team team = new Team(); Team.setLeader(leader); team.firstMettiong(); &#125;&#125; 和通过构造函数注入不同，在实例化Team时，并未指定任何发言人，而是在需要小李出场时，才调用其setLeader方法注入扮演者。 接口注入 123456789101112131415161718192021222324public interface teamInject&#123; void injectLeader(Leader leader);&#125;public class Team implements teamInject&#123; prilvate Leader leader; public void injectLeader(Leader leader)&#123; this.leader = leader; &#125; publiv setLeader(Leader leader)&#123; this.leader = leader; &#125; public void firstMetting()&#123; leader.introduce(); &#125;&#125;public class Boss&#123; public void direct()&#123; Leader leader = new li(); Team team = new Team(); Team.setLeader(leader); Team.firstMetting(); &#125;&#125; 其实，在Spring容器中，容器把第三方这个类对外封装成一个xml节点，在容器中进行查询注入，注意，这里用到两个非常重要的技术，一个是查找xml，另一个是根据方法名利用反射机制调用类。 理解：每个对象在使用他合作的对象的时候，需要自己**new Object()，这样对象间的耦合变高了.而IOC思想:Spring容器来实现这些相互依赖对象的创建和协调工作. 所谓IOC,对于Spring框架来说,就是由spring来负责控制对象的生命周期和对象间的关系.所有类的创建和销毁都由spring来控制. Spring 运行原理12345public static void main(String args[])&#123; ApplicationContext context = new FileSystemXmlApplicationContext(&quot;applicationContext.cml&quot;)); Animal animal = (Animal)context.getBean(&quot;animal&quot;); animal.say();&#125; applicationContext.xml 123&lt;bean id=&quot;animal&quot; class=&quot;com.xiaobai.pojo.Cat&quot;&gt; &lt;proterty name=&quot;name&quot; value=&quot;kitty&quot; /&gt;&lt;/bean&gt; Cat 类 123456789public class Cat implements Animal&#123; private String name; public void say()&#123; System.out.println(&quot;I am&quot; + name + &quot;!&quot;); &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; Animal 接口 123public interface Animal&#123; public void say();&#125; 输出 I am kitty! Spring是如何做到的呢？首先定义一个Bean类，这个类用来存放一个Bean拥有的属性。 123456/* Bean Id */private String id;/* Bean Class */private String type;/* Bean Property */private Map&lt;String,Object&gt; properties = new HashMap&lt;String,Object&gt;(); 一个Bean包括 id, type和 Properties。 接下来Spring开始加载配置文件，将配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HashMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spring可以注入基本类型，而且可以注入像List，Map这样的类型，接下来以Map为例看看Spring是如何保存的。 Map 配置如下： 123456789101112&lt;bean id=&quot;test&quot; class=&quot;Test&quot;&gt; &lt;property name=&quot;testMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot;&gt; &lt;value&gt;1&lt;/value&gt; &lt;/entry&gt; &lt;entry key=&quot;b&quot;&gt; &lt;value&gt;2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; Spring 如何保存上面的配置?代码如下 12345678910111213141516171819202122if(beanProperty.element(&quot;map&quot;)!=null)&#123; Map&lt;String,Object&gt; propertiesMap = new HashMap&lt;String,Object&gt;(); Element propertiesListMap = (Element)beanProperty.elements().get(0); Iterator&lt;?&gt; propertiesIterator = propertiesListMap.elements().iterator(); while(propertiesITerator.hasNext())&#123; Element vet = (ELement)propertiesIterator.next(); if(vet.getName().equals(&quot;entry&quot;))&#123; String key = vet.attributeValue(&quot;key&quot;); Iterator&lt;?&gt; = valuesIterator = vet.elements().iterator(); while(valuesIterator.hasNext())&#123; Element value = (Element)valuesIterator.next(); if(value.getName().equals(&quot;value&quot;))&#123; propertiesMap.put(key,value.getText()); &#125; if(value.getName().equals(&quot;ref&quot;)）&#123; propertiesMap.put(key,new String[]&#123; value.attributeValue(&quot;bean&quot;) &#125;); &#125; &#125; &#125; &#125; bean.getProperties().put(name,propertiesMap);&#125; 接下是核心部分，其实依赖注入(DI)思想是通过反射机制实现的。在实例化一个类时，它是通过调用类中set方法将实现保存在HashMap中的类属性注入到类中。 首先实例化一个类，像这样 123456789101112131415public static Object newInstance(String className)&#123; Class&lt;?&gt; cls = null; Object obj = null; try&#123; cls = Class.forName(className); obj = cls.newInstance(); &#125;catch(ClassNotFoundException e)&#123; throw new RuntimeException(e); &#125;catch(InstantiationException e)&#123; throw new RuntimeException(e); &#125;catch(IllegalAccessException e)&#123; throw new RuntimeException(e); &#125; return obj;&#125; 接着将这个类的依赖注入进去，像这样 123456789101112131415161718192021222324public static void setProperty(Object obj,String name,String value)&#123; Class&lt;? extends Object&gt; clazz = obj.getClass(); try&#123; String methodName = ewturn SetMethodName(name); Method[] ms = clazz.getMethods(); for(Method m:ms)&#123; if(m.getName().equals(methodName))&#123; if(m.getParameterTypes().length == 1)&#123; Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[0]; setFieldValue(clazzParameterType.getName(),value,m,obj); break; &#125; &#125; &#125; &#125;catch(SecurityException e)&#123; throw new RuntimeException(e); &#125;catch(IllegalArgumentException e)&#123; throw new RuntimeException(e); &#125;catch(IllegalAcessException e)&#123; throw new RuntimeException(e); &#125;catch(InvocationTargetException e)&#123; throw new RuntimeException(e); &#125;&#125; 最后它将这个类的实例返回给我们，我们就可以用了。以Map为例看看它是怎么做的创建一个HashMap并注入到需要注入的类中 12345678910111213if (value instanceof Map) &#123; Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet() .iterator(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); while (entryIterator.hasNext()) &#123; Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next(); if (entryMap.getValue() instanceof String[]) &#123; map.put((String) entryMap.getKey(), getBean(((String[]) entryMap.getValue())[0])); &#125; &#125; BeanProcesser.setProperty(obj, property, map); &#125; 喝水不忘挖井人参考链接：http://blog.csdn.net/shenghuaday/article/details/51399433]]></content>
      <categories>
        <category>java</category>
        <category>Spring 框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring 常见面试题]]></title>
    <url>%2F2017%2F09%2F12%2Fspring-exam%2F</url>
    <content type="text"><![CDATA[Spring 常见面试题Spring 概述 什么是 Spring ？ Spring是一个开源的java ee开发框架。Spring框架的核心功能可以应用在任何java应用程序中，但是对java ee平台上的web程序有更好的扩展性。Spring 框架的目标是使的java ee应用程序的应用开发更加便捷，通过使用pojo为基础的编程模型促进良好的编程风格。 Spring有那些优点？ 轻量级：Spring在大小和透明性方面是轻量级的，基础版本的Spring框架大约只有2MB。 控制反转(IOC)：Spring 使用控制反转技术实现了松耦合。依赖被注入的对象，而不是创建或者寻找依赖对象。 面向切面编程(AOP):Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 容器:Spring包含并管理应用程序对象的配置和生命周期。 MVC框架：Spring 的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。 事务管理:Spring 对下至本地业务上至全局业务(JAT)提供了同一的事务管理借口。 异常处理：Spring提供了一个方便的API将特定技术的异常(由JDBC,Hibernate,或JDO抛出)转化为一致的、Unchecked异常。 Spring 框架有哪些模块？ 基本模块： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaciton module Web module Web-Servlet module Web-Structs module Web-Portlet module 解释核心容器(应用上下文)模块 Spring 的基本模块，提供Spring的基本功能。BeanFactory是所有Spring应用的核心。Sroing是建立在这个模块指数上的，这也使Spring成为一个容器。 BeanFactory 和 Beanfactory 实例 BeanFactory 是工厂模式的一种实现，它使用控制反转(IOC)将应用的配置和依赖与实际的应用代码分离开来。 最常用的BeanFactory 是 XmlBeanFactory类。 XmlBeanFactory 最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。 解释AOP模块 AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。 解释抽象JDBC和DAO模块 通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。 解释对象/关系映射集成模块 Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。 解释Spring MVC模块 Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。 Spring的配置文件 Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。 Spring IoC容器是什么？ Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。 IOC有什么优点？ IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。 Spring中的依赖注入是什么？ 依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。 有哪些不同类型的IOC(依赖注入)？ 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。 Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。 Spring Beans 什么是Spring Beans？ Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。 在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。 Spring Bean中定义了什么内容？ Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系. 如何向Spring 容器提供配置元数据？ 有三种方式向Spring 容器提供元数据: * XML配置文件 * 基于注解配置 * 基于Java的配置 你如何定义bean的作用域？ 在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候用过“scope”属性定义即可。例如，当Spring需要每次产生一个新的实例，应该声明bean的scope属性为prototype。如果每次希望Spring返回一个实例，应该声明bean的scope属性为singleton。 说一下Spring中支持的bean作用域 Spring框架支持如下五种不同的作用域： * singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。 * prototype：一个bean可以定义多个实例。 * request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。 * session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境. * globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境. bean默认的scope属性是’singleton‘。 解释Spring框架红bean的声明周期 Spring容器读取XML文件中bean的定义并实例化bean。 Spring根据bean的定义设置属性值。 如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。 如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。 如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。 如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。 如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。 如果该bean实现了DisposableBean，调用destroy()方法。 什么是bean自动装配？ Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和property元素。 解释自动装配的各种模式？ 自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入: * no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。 * byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 * byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为* byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。 * constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。 * autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。 Spring 注解 什么是Spring基于java的配置？ 基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。 以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。 什么是基于注解的容器配置? 另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。 如何开启注解装配？ 注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。 @Required 注解 @Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。 @Autowired 注解 @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像 @Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。 @Qualifier 注解 当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。 Spring 数据访问 在Spring框架中如何更有效的使用JDBC？ 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。 JdbcTemplate JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。 Spring对DAO的支持 Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。 使用Spring可以通过什么方式访问Hibernate？ 使用Spring有两种方式访问Hibernate： * 使用Hibernate Template的反转控制以及回调方法 * 继承HibernateDAOSupport，并申请一个AOP拦截器节点 Spring支持的ORM Spring支持一下ORM： Hibernate iBatis JPA (Java -Persistence API) TopLink JDO (Java Data Objects) OJB 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？ 使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以下三步： * 配置Hibernate SessionFactory * 继承HibernateDaoSupport实现一个DAO * 使用AOP装载事务支持 Spring支持的事务管理类型 Spring支持如下两种方式的事务管理： * 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。 * 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。 Spring框架的事务管理有哪些优点？ 它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。 它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA). 它支持声明式事务管理。 它可以和Spring 的多种数据访问技术很好的融合。 你更推荐那种类型的事务管理？ 许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。 Spring面向切面编程(AOP) 解释AOP 面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。 切面(Aspect) AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。 在Spring AOP中concern和 cross-cutting concern的区别是什么？ Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。 Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。 连接点(Join point) 连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。 通知(Advice) 通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。 Spring切面可以执行一下五种类型的通知: * before(前置通知)：在一个方法之前执行的通知。 * after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 * after-returning(后置通知)：在某连接点正常完成后执行的通知。 * after-throwing(异常通知)：在方法抛出异常退出时执行的通知。 * around(环绕通知)：在方法调用前后触发的通知。 切入点(Pointcut) 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 什么是引入？ 引入允许我们在已有的类上添加新的方法或属性。 什么是目标对象？ 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。 什么是代理？ 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 有几种不同类型的自动代理？ BeanNameAutoProxyCreator：bean名称自动代理创建器 DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器 Metadata autoproxying：元数据自动代理 什么是织入？什么是织入应用的不同点？ 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。 解释基于XML Schema方式的切面实现 在这种情况下，切面由使用XML文件配置的类实现。 解释基于注解方式(基于@AspectJ)的切面实现 在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。 Spring的MVC框架 什么是Spring的MVC框架？ Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。 DispatcherServlet Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。 WebApplicationContext WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。 什么是Spring MVC框架的控制器？ 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。 @Controller annotation @Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。 57.@RequestMapping annotation @RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。]]></content>
      <categories>
        <category>java</category>
        <category>Spring 框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 Redis 安装]]></title>
    <url>%2F2017%2F09%2F11%2Fredis-install%2F</url>
    <content type="text"><![CDATA[CentOS 下 Redis 安装本文已下载好redis包：redis-3.0.7.tar.gz 安装redis确定好安装目录，将redis包移动到指定目录进行解压安装 12345678# tar –xzvf redis-3.0.7.tar.gz# 首先将解压文件改名# mv redis-3.0.7 redis#进入redis路径# cd /usr/local/redis/src# make &amp;&amp; make install ##安装编译 验证是否安装成功 1# redis-server –version 启动redis12# 进入redis安装路径 /usr/local/src/redis/src# redis-server 查看进程1# ps aux | grep redis 清除redis缓存1# redis-cli flushdb Redis远程连接需要关闭防火墙： 关闭防火墙—–service iptables stop 启动防火墙—–service iptables start 重启防火墙—–service iptables restart 查看防火墙状态–service iptables status 永久关闭防火墙–chkconfig iptables off 永久关闭后启用–chkconfig iptables on 修改配置文件redis.conf：123# bind 127.0.0.1 取消注释bind 127.0.0.1 取消requirepass foobar注释 远程登录：进入redis根目录，12# redis-cli –h 192.168.17.135 –p 6379# redis-cli –h 192.168.17.135 –p 6379 shutdown //服务停止 采用RedisStudio图形工具观察。 Redis自启动配置Utils文件夹在 redis 根目录下首先将utils/redis_init_script文件复制到/etc/init.d下，同时易名为redis1# cp/usr/local/redis/utils/redis_init_script /etc/rc.d/init.d/redis /usr/local/redis是redis的安装路径1# vim /etc/rc.d/init.d/redis 在文档的第二行添加1# chkconfig：2345 80 90 如果 /usr/local/bin 中没有redis-server和redis-cli，从redis目录中复制过来。在文档的 文档中：1CONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot; 将redis配置文件拷贝到 /etc/redis/路径下1234# mkdir /etc/redis# cp /usr/src/redis/redis.conf /etc/redis/6379.conf# vim /etc/rc.d/init.d/redis 将redis_${REDISPORT}.pid修改为redis.pid。 结果图：！ $ EXEC $ CONF 后边加一个 &amp; ，表示让redis作为后台服务启动，否则该服务会独占输入屏。 完成上面操作，注册服务：1# chkconfig --add redis 然后启动redis服务：1# service redis start 关闭redis服务：1# service redis stop]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scrapy分布式搭建]]></title>
    <url>%2F2017%2F09%2F11%2Fscrapy-redis%2F</url>
    <content type="text"><![CDATA[Scrapy 分布式部署使用scrapy-redis 插件实现scrapy分布式 1# pip install scrapy-redis 配置 redis 打开项目 settings.py,做如下修改: 123456SCHDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;SCHEDULER_PERSIST = TrueSCHEDULER_QUEUE_CLASS = &apos;scrapy_redis.queue.SpiderPriorityQueue&apos;REDIS_URL = NoneREDIS_HOST = &apos;127.0.0.1&apos;REDIS_PORT = 6379 Master 端 REDIS_HOST = ‘127.0.0.1’ REDIS_PORT = 6379Slave 端 REDIS_URL = ‘redis://192.168.17.134:6379’192.168.17.134 是Master端的机器IP]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Scrapyd 运行爬虫 API]]></title>
    <url>%2F2017%2F09%2F11%2Fscrapyd-scrapy%2F</url>
    <content type="text"><![CDATA[运行爬虫1$ curl http://localhost:6800/schedule.json -d project=myproject -d spider=somespider 终止爬虫1$ curl http://localhost:6800/cancel.json -d project=myproject -d job=6487ec79947edab326d6db28a2d86511e8247444 查看项目列表1$ curl http://localhost:6800/listprojects.json 查看版本列表1$ curl http://localhost:6800/listversions.json?project=myproject 查看爬虫列表1$ curl http://localhost:6800/listspiders.json?project=myproject 查看工作爬虫列表1$ curl http://localhost:6800/listjobs.json?project=myproject 删除某版本项目1$ curl http://localhost:6800/delversion.json -d project=myproject -d version=r99 删除某项目1$ curl http://localhost:6800/delproject.json -d project=myproject]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scrapyd 部署scrapy]]></title>
    <url>%2F2017%2F09%2F11%2Fscrapyd%2F</url>
    <content type="text"><![CDATA[Scrapyd部署scrapy项目打开项目根目录1# cd /usr/project/sinaSpider(projectname) 编辑 scrapy.cfg deploy后加target，同时将url的注释去掉 执行部署命令：1# scrapyd-deploy target –p projectname 也就是：1# scrapyd-deploy scrapyd –p sinaSpider 使用 supervisor 对scrapyd 进行管理防止 scrapyd 经常挂掉 scrapyd 配置文件如果设置了scrapyd的配置文件,scrapyd 会搜索如下路径：12345• /etc/scrapyd/scrapyd.conf (Unix)• c:\scrapyd\scrapyd.conf (Windows)• /etc/scrapyd/conf.d/* (in alphabetical order, Unix)• scrapyd.conf• ~/.scrapyd.conf (users home directory) 我的配置文件存储路径：1etc/scrapyd/scrapyd.conf 配置文件内容：1234567891011121314151617181920212223242526[scrapyd]eggs_dir = /usr/scrapyd/eggs # 爬虫部署存储路径logs_dir = /usr/scrapyd/logs # 爬虫日志文件存储路径jobs_to_keep = 100dbs_dir = /usr/scrapyd/dbsmax_proc = 0max_proc_per_cpu = 800 # 每台cpu 可运行的scrapy爬虫进程finished_to_keep = 100poll_interval = 5.0bind_address = 192.168.17.30 # 机器地址iphttp_port = 6800debug = offrunner = scrapyd.runnerapplication = scrapyd.app.applicationlauncher = scrapyd.launcher.Launcherwebroot = scrapyd.website.Root[services]schedule.json = scrapyd.webservice.Schedulecancel.json = scrapyd.webservice.Canceladdversion.json = scrapyd.webservice.AddVersionlistprojects.json = scrapyd.webservice.ListProjectslistversions.json = scrapyd.webservice.ListVersionslistspiders.json = scrapyd.webservice.ListSpidersdelproject.json = scrapyd.webservice.DeleteProjectdelversion.json = scrapyd.webservice.DeleteVersionlistjobs.json = scrapyd.webservice.ListJobs 为scrapyd 添加守护进程(supervisor) 安装supeervisor 1# pip install supervisor 在 构建supervisor的配置文件：1# echo_supervisord_conf &gt; /etc/supervisord.conf 修改配置文件： 1234567891011121314151617181920[unix_http_server]file=/tmp/supervisor.sock ; (the path to the socket file)chmod=0775 ; socket file mode (default 0700)[inet_http_server] ; inet (TCP) server disabled by defaultport=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface) # web服务的IP和端口号username=user ; (default is no username (open server)) # 登录web界面的用户名password=123 ; (default is no password (open server)) # 登录web界面的密码[supervisord]logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log)logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB)logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace)pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid)nodaemon=false ; (start in foreground if true;default false)minfds=1024 ; (min. avail startup file descriptors;default 1024)minprocs=200 ; (min. avail process descriptors;default 200)[supervisorctl]serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket[include]files = /etc/supervisor/*.conf 在etc 下建立文件夹 supervisor建立守护进程配置文件scrapyd.conf 内容： 1234[program:scrapyd]command=/usr/local/bin/scrapyd # scrapyd 的执行路径autostart=trueautorestart=true 设置supervisor开机自启动： 在 /etc/init.d 文件夹下建立脚本文件 supervisord内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243#! /bin/sh#chkconfig: 2345 95 20 # description: Description of the script # processname: supervisordPATH=/usr/local/bin:/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/binPROGNAME=supervisordDAEMON=/usr/local/bin/$PROGNAMECONFIG=/etc/$PROGNAME.confPIDFILE=/var/run/$PROGNAME.pidDESC=&quot;supervisord daemon&quot;SCRIPTNAME=/etc/init.d/$PROGNAME# Gracefully exit if the package has been removed.test -x $DAEMON || exit 0start()&#123; echo -n &quot;Starting $DESC: $PROGNAME&quot; $DAEMON -c $CONFIG echo &quot;...&quot;&#125;stop()&#123; echo -n &quot;Stopping $DESC: $PROGNAME&quot; supervisor_pid=$(cat $PIDFILE) kill -15 $supervisor_pid echo &quot;...&quot;&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; restart) stop start ;; *) echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart&#125;&quot; &gt;&amp;2 exit 1 ;;esacexit 0 保存后修改文件权限：12345678# chmod 777 /etc/init.d/supervisord# /etc/init.d/supervisord start或者# service supervisord start配置开机自启动：# chkconfig supervisord on]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos下Scrapy环境搭建]]></title>
    <url>%2F2017%2F09%2F11%2Fcentos-python%2F</url>
    <content type="text"><![CDATA[Scrapy 环境搭建 Centos 6.5 默认python2.6 ,但是scrapy 支持 python &gt;=2.7 scrapy python2.7 Vmware xshell 升级python1# [root@localhost ~]# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz 进入路径并编译：1234567891011[root@localhost ~]# tar zxf Python-2.7.3.tgz[root@localhost ~]# cd Python-2.7.3[root@localhost Python-2.7.3]# ./configure[root@localhost Python-2.7.3]#make &amp;&amp; make install[root@localhost Python-2.7.3]# mv /usr/bin/python /usr/bin/python_old[root@localhost Python-2.7.3]# python --version-bash: /usr/bin/python: No such file or directory[root@localhost Python-2.7.3]# ln -s /usr/local/bin/python2.7 /usr/bin/python[root@localhost Python-2.7.3]# python --versionPython 2.7.3 更改yum的配置文件（因为升级到python2.7之后，原来的yum就无法使用了）1[root@localhost Python-2.7.3]# vim /usr/bin/yum 1[root@localhost Python-2.7.3]# yum intall zlib-devel 再重新编译python2.7 easy_install 安装首先安装 openssl 和 openssl-devel12345678# yum install openssl# yum install openssl-devel# wget --no-cookie --no-check-certificate http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz# tar xzvf setuptools-0.6c11.tar.gz# cd setuptools-0.6c11# python setup.py build# python setup.py install pip安装123456789# yum install openssl# yum install openssl-devel# ./configure# make &amp;&amp; make install# wget &quot;https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz#md5=834b2904f92d46aaa333267fb1c922bb&quot; --no-check-certificate# tar -xzvf pip-1.5.4.tar.gz# cd pip-1.5.4# python setup.py install Scrapy 安装安装依赖Twisted 依赖 bzip2-devel12345678910111213141516171819# yum install bzip2-devel依赖 lxml# yum install lxml依赖 w3lib# yum install w3lib报 Unicode 错误# easy_install Cython# yum install libxslt-devel libxml2-devel llibffi-devel# yum install gcc libffi-devel# pip install pydispatcher# yum install sqlite-devel缺少 cryptography 包# yum install cryptography# pip install scrapy Scrapyd 安装123456# pip install attrs# easy_install pyasnl-modules# easy_install pyasnl# pip install scrapyd# pip install scrapyd-client# scrapyd 在虚拟机中打开浏览器输入 localhost：6800 环境搭建完成，可能在安装的过程中，需要安装其他的包，缺什么就pip安装什么就可以。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Java】PriorityQueue实现最大堆和最小堆]]></title>
    <url>%2F2017%2F09%2F10%2Fzuidaduiandzuixiaodui%2F</url>
    <content type="text"><![CDATA[PriorityQueue 实现最大堆和最小堆概念：堆是一种经过排序的完全二叉树，其中任一非终端节点的数值均不大于(或不小于)其左孩子和右孩子的节点。 * 最小堆(小根堆) 根节点(堆顶)的值在堆里是最小的堆,称为最小堆 * 最大堆(大根堆) 根节点(堆顶)的值在堆里是最大的堆,称为最大堆 借助PriorityQueue 可以实现小根堆和大根堆。 PriorityQueue 的容量没有界限,并且默认排序是自然排序,队头元素是最小元素,可以拿来做最小堆使用(注意：默认的PriorityQueue并非保证了整个队列是有序的,只是保证了队头是最小的) 对于大根堆,就要借助于comparator比较器实现最大堆。(默认的初始容量：11) 代码实现： 123456PriorityQueue &lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(11,new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1,Integer o2)&#123; return o2.compareTo(o1); &#125;&#125;) 最大堆和最小堆实例：已知关键字序列5,8,12,19,28,20,15,22是最小堆，插入关键字3，调整后得到的最小堆是() 算法实例：题目描述(数据流中的中位数)如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738import java.util.PriorityQueue;import java.util.Comparator;/** 最大堆中 放 较小的一半， 最小值放较大的一半* 如果是奇数个，就最大堆数量比最小堆数量大 1，如果是偶数，取最大堆得的最小值和最小堆得最大值的平均数*/public class Solution &#123; private int count = 0; private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;(); private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(11,new Comparator&lt;Integer&gt;()&#123; public int compare(Integer o1,Integer o2)&#123; return o2.compareTo(o1); &#125; &#125;); public void Insert(Integer num) &#123; if(count % 2 == 1)&#123; // 如果是偶数，放入最小堆中 maxHeap.offer(num); minHeap.offer(maxHeap.poll()); &#125;else&#123; // 如果是奇数，放入最大堆中 minHeap.offer(num); maxHeap.offer(minHeap.poll()); &#125; count++; &#125; // 如果是奇数，就取最大堆中的最大值，如果是偶数，就取最大堆中的最大值和最小堆中的最小值的平均值 public Double GetMedian() &#123; if(count % 2 == 0)&#123; return new Double((maxHeap.peek()+minHeap.peek()))/2; &#125;else&#123; return new Double(maxHeap.peek()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】equals方法和hashCode方法]]></title>
    <url>%2F2017%2F09%2F09%2Fjava-hashmap%2F</url>
    <content type="text"><![CDATA[HashMap工作原理Object类的两个方法： 1234567/** JNI ,调用底层其他语言实现*/public native int hashCode();/** 默认同==,直接比较对象 */public boolean equals(Object o)&#123; return (this == o);&#125; hashCode是本地方法,返回的是对象的地址值。对象的equals()比较的是两个对象的地址值,如果equals()相等,hashCode()肯定也相等。 String 类中重写了equals方法，比较的是字符串的值，源码实现: 12345678910111213141516171819202122public boolean equals(Object o)&#123; if(this == o)&#123; return true; &#125; if(o instanceof String)&#123; String anString = (String)o; int n = value.length; if(n == anString.value.length)&#123; char[] v1 = value; char[] v2 = anString.value; int i = 0; while(n-- != 0)&#123; if(v1[i] != v2[i])&#123; return false; &#125; i++; &#125; return true; &#125; &#125; return false;&#125; 重写equals的四个条件： 自反性：对于任何非空引用值x，x.equals(x)都返回true。 对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值x,x.equals(null)都应返回 false。 Object 对象: 对于任何非空引用值 x 和 y,当且仅当 x 和 y 引用同一个对象时,此方法才返回 true。 当equals重写时,hashCode 方法也要重写。 相同的对象必须有相同的哈希码。 equals() 相等的两个对象,hashCode()一定相等;equals 不相等的两个对象,不能证明他们的hashCode不相等.可能是由于哈希碰撞产生的。hashCode()不相等的两个对象,equals也肯定不相等。 下面看一个具体的例子： 1234567891011121314151617181920212223242526272829303132333435package com.xiaobai.demo; public class RectObject &#123; public int x; public int y; public RectObject(int x,int y)&#123; this.x = x; this.y = y; &#125; @Override public int hashCode()&#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj)&#123; if(this == obj) return true; if(obj == null) return false; if(getClass() != obj.getClass()) return false; final RectObject other = (RectObject)obj; if(x != other.x)&#123; return false; &#125; if(y != other.y)&#123; return false; &#125; return true; &#125; &#125; 重写了父类Object中的hashCode和equals方法，看到hashCode和equals方法中，如果两个RectObject对象的x,y值相等的话他们的hashCode值是相等的，同时equals返回的是true;下面是测试代码： 123456789101112131415package com.xiaobai.demo; import java.util.HashSet; public class Demo &#123; public static void main(String[] args)&#123; HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;(); RectObject r1 = new RectObject(3,3); RectObject r2 = new RectObject(5,5); RectObject r3 = new RectObject(3,3); set.add(r1); set.add(r2); set.add(r3); set.add(r1); System.out.println(&quot;size:&quot;+set.size()); &#125; &#125; 运行结果:size:2为什么会是2呢？这个很简单了吧，因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象 下面我们把RectObject对象中的hashCode方法注释，即不重写Object对象中的hashCode方法，在运行一下代码： 运行结果：size:3这个结果也是很简单的，首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3 下面我们把RectObject对象中的equals方法中的内容注释，直接返回false，不注释hashCode方法，运行一下代码： 运行结果：size:3这个结果就有点意外了，我们来分析一下：首先r1和r2的对象比较hashCode，不相等，所以r2放进set中，再来看一下r3,比较r1和r3的hashCode方法，是相等的，然后比较他们两的equals方法，因为equals方法始终返回false,所以r1和r3也是不相等的，r3和r2就不用说了，他们两的hashCode是不相等的，所以r3放进set中，再看r4,比较r1和r4发现hashCode是相等的，在比较equals方法，因为equals返回false,所以r1和r4不相等，同一r2和r4也是不相等的，r3和r4也是不相等的，所以r4可以放到set集合中，那么结果应该是size:4,那为什么会是3呢？这时候我们就需要查看HashSet的源码了，下面是HashSet中的add方法的源码： 123456789101112131415/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null ? e2==null : e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; 这里我们可以看到其实HashSet是基于HashMap实现的，我们在点击HashMap的put方法，源码如下： 12345678910111213141516171819202122232425262728293031/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 我们主要来看一下if的判断条件，首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。 最后我们在来看一下hashCode造成的内存泄露的问题：看一下代码：1234567891011121314151617package com.xiaobai.demo; import java.util.HashSet; public class Demo &#123; public static void main(String[] args)&#123; HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;(); RectObject r1 = new RectObject(3,3); RectObject r2 = new RectObject(5,5); RectObject r3 = new RectObject(3,3); set.add(r1); set.add(r2); set.add(r3); r3.y = 7; System.out.println(&quot;删除前的大小size:&quot;+set.size()); set.remove(r3); System.out.println(&quot;删除后的大小size:&quot;+set.size()); &#125; &#125; 运行结果：删除前的大小size:3删除后的大小size:3 发现一个问题了，而且是个大问题呀，我们调用了remove删除r3对象，以为删除了r3,但事实上并没有删除，这就叫做内存泄露，就是不用的对象但是他还在内存中。所以我们多次这样操作之后，内存就爆了。看一下remove的源码： 123456789101112131415/** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null ? e==null : o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; 然后再看一下remove方法的源码： 12345678910111213/** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; 在看一下removeEntryForKey方法源码：12345678910111213141516171819202122232425262728293031/** * Removes and returns the entry associated with the specified key * in the HashMap. Returns null if the HashMap contains no mapping * for this key. */ final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; 我们看到，在调用remove方法的时候，会先使用对象的hashCode值去找到这个对象，然后进行删除，这种问题就是因为我们在修改了r3对象的y属性的值，又因为RectObject对象的hashCode方法中有y值参与运算,所以r3对象的hashCode就发生改变了，所以remove方法中并没有找到r3了，所以删除失败。即r3的hashCode变了，但是他存储的位置没有更新，仍然在原来的位置上，所以当我们用他的新的hashCode去找肯定是找不到了。其实上面的方法实现很简单的：如下图： 很简单的一个线性的hash表，使用的hash函数是mod,源码如下： 123456/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 这个其实就是mod运算，只是这种运算比%运算要高效。1,2,3,4,5表示是mod的结果，每个元素对应的是一个链表结构，所以说想删除一个Entry的话，首先得到hashCode，从而获取到链表的头结点，然后再遍历这个链表，如果hashCode和equals相等就删除这个元素。上面的这个内存泄露告诉我一个信息：如果我们将对象的属性值参与了hashCode的运算中，在进行删除的时候，就不能对其属性值进行修改，否则会出现严重的问题。 其实我们也可以看一下8种基本数据类型对应的对象类型和String类型的hashCode方法和equals方法。其中8中基本类型的hashCode很简单就是直接返回他们的数值大小，String对象是通过一个复杂的计算方式，但是这种计算方式能够保证，如果这个字符串的值相等的话，他们的hashCode就是相等的。8种基本类型的equals方法就是直接比较数值，String类型的equals方法是比较字符串的值的。 参考:http://blog.csdn.net/jiangwei0910410003/article/details/22739953]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串中找出连续最长的数字串]]></title>
    <url>%2F2017%2F09%2F09%2FFindLongNum%2F</url>
    <content type="text"><![CDATA[题目描述读入一个字符串str，输出字符串str中的连续最长的数字串 输入描述:个测试输入包含1个测试用例，一个字符串str，长度不超过255。 输出描述:在一行内输出str中里连续最长的数字串。 示例11234输入abcd12345ed125ss123456789输出123456789 思路： 1. 定义一个值，数字字符串的长度 2. 定义StringBuilder，保存数字字符串 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); char[] ch = s.toCharArray(); int max = 0; // 保存最终最大值的长度 int temp = 0; // 保存当前连续数字字符串的长度 String result = &quot;&quot;; // 保存对吼的字符串结果 StringBuilder sb = new StringBuilder(); // 保存当前的连续数字字符串 for(int i=0;i&lt;ch.length;i++)&#123; if(Character.isDigit(ch[i]))&#123; temp++; sb.append(ch[i]); &#125;else&#123; sb.delete(0,sb.length()); temp = 0; &#125; if(temp &gt; max)&#123; max = temp; result = sb.toString(); &#125; &#125; System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fibonacci 数列]]></title>
    <url>%2F2017%2F09%2F09%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[题目描述Fibonacci数列是这样定义的：F[0] = 0F[1] = 1for each i ≥ 2: F[i] = F[i-1] + F[i-2]因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, …，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。 输入描述输入为一个正整数N(1 ≤ N ≤ 1,000,000) 输出描述输出一个最小的步数变为Fibonacci数” 思路： 判断 N 与相邻两个数的差的大小，以 N 作为界限 代码实现1234567891011121314151617import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int Num = in.nextInt(); int a = 0; int b = 1; while(b&lt;=Num)&#123; int tmp = a + b; a = b; b = tmp; &#125; int result = (b-Num)&gt;(Num-a)?(Num-a):(b-Num); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2017%2F09%2F08%2Ftreenode-reconstruct%2F</url>
    <content type="text"><![CDATA[重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 前序遍历根左右 中序遍历左根右 后序遍历左右根 思路： 已知前序遍历和中序遍历的结果，前序遍历可以推出 根节点，中序遍历可以推出左子树和右子树 例如： * 前序遍历序列： {1,2,4,7,3,5,6,8} 确认根节点为 1 * 中序遍历序列： {4,7,2,1,5,3,8,6} 找到根节点索引，根节点左边即为左子树：{4,7,2} ，右子树：{5,3,8,6} * 依次确定： * 左子树 前序遍历为 {2,4,7} 中序遍历为 {4,7,2} * 右子树 前序遍历为 {3,5,6,8} 中序遍历为 {5,3,8,6} .... 代码实现：12345678class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Solution&#123; public static void main(String args[])&#123; int[] pre = &#123;1,2,4,7,3,5,6,8&#125;; int[] in = &#123;4,7,2,1,5,3,8,6&#125;; TreeNode result = TreeNodeConstruct(pre,in); &#125; public static TreeNode TreeNodeConstruct(int[] pre,int[] in)&#123; ArrayList&lt;Integer&gt; preList = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; inList = new ArrayList&lt;Integer&gt;(); for(int i:pre)&#123; preList.add(pre); &#125; for(int j:in)&#123; inList.add(j); &#125; return getRoot(preList,inList); &#125; public static TreeNode getRoot(List&lt;Integer&gt; preList,List&lt;Integer&gt; inList)&#123; if(preList.size() == 0)&#123; return null; &#125; int val = preList.get(0); // 获取根节点 TreeNode root = new TreeNode(val); int index = inList.indexOf(val); // 获取中序遍历序列中根节点的索引，从而确定中序遍历左子树和中序遍历右子树 // subList(preIndex,lastIndex) 截取List ,不包含lastIndex ,但是包含 preIndex List&lt;Integer&gt; inLeft = inList.subList(0,index); // 获取中序遍历左子树 List&lt;Integer&gt; inRight = inList.subList(index+1,inList.size()); // 获取中序遍历右子树 List&lt;Integer&gt; preLeft = preList.subList(1,inLeft.size()+1); // 获取前序遍历左子树 List&lt;Integer&gt; preRight = preList,subList(inLeft+1,preList.size()); // 获取前序遍历右子树 root.left = getRoot(preLeft,inLeft); root.right = getRoot(preRight,inRight); return root; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Java】Stack 类]]></title>
    <url>%2F2017%2F09%2F08%2Fjava-stack%2F</url>
    <content type="text"><![CDATA[JAVA Stack 类栈是Vector的一个子类，他是实现了一个标准的后进先出的栈。 方法： empty()测试堆栈是否为空。 peek()查看堆栈顶部的对象，但不从堆栈中移除它。 pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 push()把项压入堆栈顶部。 search()返回对象在堆栈中的位置，以 1 为基数。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入两个链表，找出它们的第一个公共结点。]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-commonnode%2F</url>
    <content type="text"><![CDATA[输入两个链表，找出它们的第一个公共结点。思路:使用 stack 1234567class LinkNode&#123; int val; LinkNode next = null; LinkNode(int val)&#123; this.val = val; &#125;&#125; 代码实现1234567891011121314151617181920212223import java.util.Stack;public class Solution&#123; public LinkNode FindCommonNode(LinkNode list1,LinkNode list2)&#123; Stack&lt;LinkNode&gt; stack1 = new Stack&lt;LinkNode&gt;(); Stack&lt;LinkNode&gt; stack2 = new Stack&lt;LinkNode&gt;(); LinkNode result = null; while(list1 != null)&#123; stack1.push(list1); list1 = list1.next; &#125; while(list2 != null)&#123; stack2.push(list2); list2 = list2.next; &#125; // 只要 两个链表中的值相等，就进入循环，直到循环结束，最后一次相等的值就是首次相等的值 while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty() &amp;&amp; stakc1.peek() == stack2.peek())&#123; stack1.pop(); result = stack2.pop(); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树转换成双向链表]]></title>
    <url>%2F2017%2F09%2F08%2FTwoTree-linklist%2F</url>
    <content type="text"><![CDATA[输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。思路： 利用二叉树的中序遍历是是递增的。 12345 5 3 81 4 6 9中序遍历(左根右): 1 3 4 5 6 8 9 代码实现： 12345678public class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930import java.util.Stack;public class Solution&#123; public TreeNode Convert(TreeNode root)&#123; if(root == null) return null; TreeNode p = root; TreeNode pre = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); boolean isFirst = true; // 确定首节点 while(p!=null || !stack.isEmpty())&#123; while(p != null!)&#123; stack.push(p); p = p.left; &#125; p = stack.pop(); // 确定首节点 if(isFirst)&#123; root = p; // 首节点 pre = root; // 前一节点 isFirst = fasle; &#125;else&#123; pre.right = p; // 前一节点右指向当前节点 p.left = pre; // 当前节点左指向前一节点 pre = p; //当前节点变为前一节点 &#125; p = pre.right; // 取右节点 &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并两个链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-merge-two%2F</url>
    <content type="text"><![CDATA[输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。非递归版本123456789/*public class ListNode&#123; int val; ListNode node = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution&#123; public ListNode merge(ListNode list1,ListNode list2)&#123; if(list1 == null) return list2; if(list2 == null) return list1; // 确定头结点 ListNode head = null; // 保存当前节点 ListNode current = null; // 当list1 和 list2 都不为空时，比较两个链表的值 while(list1 != null &amp;&amp; list2 != null)&#123; // 如果list1的值比list2的值较小 if(list1.val&lt;=list2.val)&#123; // 确定头结点 if(head == null)&#123; head = current = list1; &#125;else&#123; current.next = list1; // 保存当前节点 current = current.next; &#125; // 下一节点 list1 = list1.next; &#125;else&#123; // 确定头结点 if(head == null)&#123; head = current = list2; &#125;else&#123; current.next = list2; current = current.next; &#125; list2 = list2.next; &#125; &#125; if(list1 == null)&#123; current.next = list2; &#125; if(list2 == null)&#123; current.next = list1; &#125; return head; &#125;&#125; 递归版本1234567891011121314151617public class Solution&#123; public ListNode Merge(ListNode list1,ListNode list2)&#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val&lt;=list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入一个链表从尾到头进行打印]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-tail-head%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表输入一个链表，从尾到头打印链表每个节点的值。 思路：利用 栈 的先进后出的原则123456789/*public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122import java.util.Stack;import java.util.ArrayList;public class Solution&#123; public ArrayList&lt;Integer&gt; PrintTailToHead(ListNode node)&#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); if(node == null)&#123; return result; &#125; ListNode head = node; while(head.next != null)&#123; stack.push(head.val); head = head.next; &#125; stack.push(head.val); while(!stack.isEmpty())&#123; result.add(stack.pop()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻转链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-reverse%2F</url>
    <content type="text"><![CDATA[翻转链表1-&gt;2-&gt;3-&gt;4-&gt;5head = 1next = 2 1-&gt;2 保存1到2 的指针防止造成断链 null&lt;-1 2-&gt;3..-&gt;5head.next = pre 1-&gt;nullpre = 1head = next = 2 head = 2next = 3 2-&gt;3head.next = pre = 1 1&lt;-2-&gt;3..-&gt;5pre = head = 2head = next = 3… 123456789101112131415161718192021222324public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;public class Solution&#123; public ListNode ReverseList(ListNode listnode)&#123; if(listnode == null) return null; ListNode next = null; // 保存当前节点指向下一节点的指针 ListNode pre = null; // 保存当前节点的上一个节点 while(listnode != null)&#123; next = listnode.next; // 保存指针，防止断链 listnode.next = pre; pre = listnode; listnode = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP&&UDP常见面试题]]></title>
    <url>%2F2017%2F09%2F07%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP协议和UDP协议的区别是什么 TCP保证数据按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，只是努力交付。 TCP协议所需资源较多，TCP首部需20字节（不算可选项），UDP首部字段只需8字节。 TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率。 TCP是一对一的连接，UDP支持一对一，多对多，一对多的通信。 TCP是面向的字节流的服务，UDP是面向的报文的服务。 请详细介绍TCP协议建立连接和终止连接的过程？ 建立连接：三次握手 关闭连接：四次挥手 常见的应用中有那些是应用TCP协议的，那些是UDP协议的，为什么？ 以下应用一般或必须使用UDP实现？ 多播的信息一定要用UDP实现，因为TCP只支持一对一通信。 如果一个应用场景中大多是简短的信息，适合用UDP实现，因为udp是基于报文的它直接上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输速率。 如果一个应用场景性能甚于完整性和安全性，那么适合udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达速度快，因此比较适合udp。 如果要求快速响应，那么udp比较合适。 如果有要利用udp的快速响应有点，又想可靠传输，那么只能靠上层应用自己制定规则。 常见的使用UDP的例子：ICQ，QQ的聊天模块。 以qq为例：登录采用TCP协议和http协议，和好友间的信息发送，主要用udp协议，内网文件传输采用p2p技术。 登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pyspider windows 下环境搭建]]></title>
    <url>%2F2017%2F09%2F07%2Fpyspider-environment%2F</url>
    <content type="text"><![CDATA[依赖 lxml（建议采用windows 编译好的） pycurl phantomjs(将 phantomjs.exe 放在python path 路径下即可) 建议采用 python2.7 32bit（windows环境下）1# pip install pyspider 注意：用pip下载的pyspider不是最新版本，在使用phantomjs进行渲染的时候，发现无法使用 代理 和 执行 js动作，需要更新pyspider 的 fetch_script.js 文件，[pyspider](https://github.com/binux/pyspider)地址 运行1# pyspider all 打开浏览器，输入 localhost:5000 即可dashboard 界面 点击 create ，填写项目名称，开始爬行之旅 搭建完成。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyspider</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lru 计算缺页]]></title>
    <url>%2F2017%2F09%2F07%2Flru%2F</url>
    <content type="text"><![CDATA[在一个请求页式存储管理中，一个程序的页面走向为 3、4、2、1、4、5、3、4、5、1、2，并采用 LRU 算法。设分配给该程序的存储块数 S 分别为 3 和 4，在该访问中发生的缺页次数 F 是 ?解： LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的。 123456789101112131415161718以下用x表示缺页的情况1.S=33,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 5 1 3 4 2 1 4 5 4 3 5x x x x x x x x所以F=82.S=43,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 3 1 3 4 2 1 4 5 4 5 3 3 3 2 1 1 1 4 5x x x x x x x所以F=7]]></content>
      <categories>
        <category>算法</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 navicat 破解]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos%2F</url>
    <content type="text"><![CDATA[破解方案： 第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。 cd /home/hadoop/.navicat/此文件夹下有一个system.reg文件 rm system.reg 把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql的配置修改]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos1%2F</url>
    <content type="text"><![CDATA[linux下mysql的配置修改 使用CentOS下yum安装mysql mysql启动和停止等操作 12345678910111213141516# /etc/init.d/mysqld start;# service mysqld start;#service mysqld stop;#/etc/init.d/mysqld stop;# service mysqld restart;#/etc/init.d/mysqld restart;#service mysqld status;设置新的最大连接数为200：mysql&gt; set GLOBAL max_connections=200 显示当前运行的Query：mysql&gt; show processlist 显示当前状态：mysql&gt; show status 退出客户端：mysql&gt; exit mysql配置文件 以使用的MySQL配置文件共有５个。最后４个位于/usr/share/mysql-server-*/目录中。·/etc/my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。 mysql配置参数一般我们会把配置文件（例如：my-small.cnf）拷贝到/etc/my.cnf只需要修改这个配置文件就可以了，使用mysqladmin variables extended-status -u root -p可以看到目前的参数，有3个配置参数是最重要的，即123key_buffer_size,query_cache_size,table_cache。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
</search>
