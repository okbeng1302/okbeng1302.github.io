<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tail-head]]></title>
    <url>%2F2017%2F09%2F08%2Ftail-head%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[输入一个链表从尾到头进行打印]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-tail-head%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表输入一个链表，从尾到头打印链表每个节点的值。 思路：利用 栈 的先进后出的原则123456789/*public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122import java.util.Stack;import java.util.ArrayList;public class Solution&#123; public ArrayList&lt;Integer&gt; PrintTailToHead(ListNode node)&#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); if(node == null)&#123; return result; &#125; ListNode head = node; while(head.next != null)&#123; stack.push(head.val); head = head.next; &#125; stack.push(head.val); while(!stack.isEmpty())&#123; result.add(stack.pop()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻转链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-reverse%2F</url>
    <content type="text"><![CDATA[翻转链表1-&gt;2-&gt;3-&gt;4-&gt;5head = 1next = 2 1-&gt;2 保存1到2 的指针防止造成断链 null&lt;-1 2-&gt;3..-&gt;5head.next = pre 1-&gt;nullpre = 1head = next = 2 head = 2next = 3 2-&gt;3head.next = pre = 1 1&lt;-2-&gt;3..-&gt;5pre = head = 2head = next = 3… 123456789101112131415161718192021222324public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;public class Solution&#123; public ListNode ReverseList(ListNode listnode)&#123; if(listnode == null) return null; ListNode next = null; // 保存当前节点指向下一节点的指针 ListNode pre = null; // 保存当前节点的上一个节点 while(head != null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP&&UDP常见面试题]]></title>
    <url>%2F2017%2F09%2F07%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP协议和UDP协议的区别是什么 TCP保证数据按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，只是努力交付。 TCP协议所需资源较多，TCP首部需20字节（不算可选项），UDP首部字段只需8字节。 TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率。 TCP是一对一的连接，UDP支持一对一，多对多，一对多的通信。 TCP是面向的字节流的服务，UDP是面向的报文的服务。 请详细介绍TCP协议建立连接和终止连接的过程？ 建立连接：三次握手 关闭连接：四次挥手 常见的应用中有那些是应用TCP协议的，那些是UDP协议的，为什么？ 以下应用一般或必须使用UDP实现？ 多播的信息一定要用UDP实现，因为TCP只支持一对一通信。 如果一个应用场景中大多是简短的信息，适合用UDP实现，因为udp是基于报文的它直接上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输速率。 如果一个应用场景性能甚于完整性和安全性，那么适合udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达速度快，因此比较适合udp。 如果要求快速响应，那么udp比较合适。 如果有要利用udp的快速响应有点，又想可靠传输，那么只能靠上层应用自己制定规则。 常见的使用UDP的例子：ICQ，QQ的聊天模块。 以qq为例：登录采用TCP协议和http协议，和好友间的信息发送，主要用udp协议，内网文件传输采用p2p技术。 登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pyspider windows 下环境搭建]]></title>
    <url>%2F2017%2F09%2F07%2Fpyspider-environment%2F</url>
    <content type="text"><![CDATA[依赖 lxml（建议采用windows 编译好的） pycurl phantomjs(将 phantomjs.exe 放在python path 路径下即可) 建议采用 python2.7 32bit（windows环境下）1# pip install pyspider 注意：用pip下载的pyspider不是最新版本，在使用phantomjs进行渲染的时候，发现无法使用 代理 和 执行 js动作，需要更新pyspider 的 fetch_script.js 文件，[pyspider](https://github.com/binux/pyspider)地址 运行1# pyspider all 打开浏览器，输入 localhost:5000 即可dashboard 界面 点击 create ，填写项目名称，开始爬行之旅 搭建完成。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyspider</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lru 计算缺页]]></title>
    <url>%2F2017%2F09%2F07%2Flru%2F</url>
    <content type="text"><![CDATA[在一个请求页式存储管理中，一个程序的页面走向为 3、4、2、1、4、5、3、4、5、1、2，并采用 LRU 算法。设分配给该程序的存储块数 S 分别为 3 和 4，在该访问中发生的缺页次数 F 是 ?解： LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的。 123456789101112131415161718以下用x表示缺页的情况1.S=33,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 5 1 3 4 2 1 4 5 4 3 5x x x x x x x x所以F=82.S=43,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 3 1 3 4 2 1 4 5 4 5 3 3 3 2 1 1 1 4 5x x x x x x x所以F=7]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 navicat 破解]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos%2F</url>
    <content type="text"><![CDATA[破解方案： 第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。 cd /home/hadoop/.navicat/此文件夹下有一个system.reg文件 rm system.reg 把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql的配置修改]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos1%2F</url>
    <content type="text"><![CDATA[linux下mysql的配置修改 使用CentOS下yum安装mysql mysql启动和停止等操作 12345678910111213141516# /etc/init.d/mysqld start;# service mysqld start;#service mysqld stop;#/etc/init.d/mysqld stop;# service mysqld restart;#/etc/init.d/mysqld restart;#service mysqld status;设置新的最大连接数为200：mysql&gt; set GLOBAL max_connections=200 显示当前运行的Query：mysql&gt; show processlist 显示当前状态：mysql&gt; show status 退出客户端：mysql&gt; exit mysql配置文件 以使用的MySQL配置文件共有５个。最后４个位于/usr/share/mysql-server-*/目录中。·/etc/my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。 mysql配置参数一般我们会把配置文件（例如：my-small.cnf）拷贝到/etc/my.cnf只需要修改这个配置文件就可以了，使用mysqladmin variables extended-status -u root -p可以看到目前的参数，有3个配置参数是最重要的，即123key_buffer_size,query_cache_size,table_cache。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
</search>
