<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring IOC 原理]]></title>
    <url>%2F2017%2F09%2F12%2Fspring-ioc%2F</url>
    <content type="text"><![CDATA[Spring IOC 原理IOC 简介 IOC 就是应用本身不依赖对象的创建和维护而是交给外部容器（spring），就是把应用和对象之间解耦，控制权交给外部容器。 IOC控制反转：说的是创建对象实例的控制权从代码控制玻璃到IOC容器控制，实际上就是我们现在说的第三方，侧重于原理。 DI依赖注入：说的是创建对象实例时，为这个对象注入属性值，或其他对象实例，侧重于实现。 注入方式 构造函数注入 1234567891011121314151617public class Team&#123; private Leader leader; public Team(Leader leader)&#123; this.leader = leader; &#125; public void firstMetting()&#123; leader.introduce(); &#125;&#125;public class Boss&#123; public void direct()&#123; Leader leader = new Li(); Team team = new Team(leader); team.firstMetting(); &#125;&#125; 属性注入 123456789101112131415161718public class Team&#123; private Leader leader; public SetLeader(Leader leader)&#123; this.leader = leader; &#125; public void firstMetting()&#123; leader.introduce(); &#125;&#125;public class Boss&#123; public void direct()&#123; Leader leader = new Li(); Team team = new Team(); Team.setLeader(leader); team.firstMettiong(); &#125;&#125; 和通过构造函数注入不同，在实例化Team时，并未指定任何发言人，而是在需要小李出场时，才调用其setLeader方法注入扮演者。 接口注入 123456789101112131415161718192021222324public interface teamInject&#123; void injectLeader(Leader leader);&#125;public class Team implements teamInject&#123; prilvate Leader leader; public void injectLeader(Leader leader)&#123; this.leader = leader; &#125; publiv setLeader(Leader leader)&#123; this.leader = leader; &#125; public void firstMetting()&#123; leader.introduce(); &#125;&#125;public class Boss&#123; public void direct()&#123; Leader leader = new li(); Team team = new Team(); Team.setLeader(leader); Team.firstMetting(); &#125;&#125; 其实，在Spring容器中，容器把第三方这个类对外封装成一个xml节点，在容器中进行查询注入，注意，这里用到两个非常重要的技术，一个是查找xml，另一个是根据方法名利用反射机制调用类。 理解：每个对象在使用他合作的对象的时候，需要自己**new Object()，这样对象间的耦合变高了.而IOC思想:Spring容器来实现这些相互依赖对象的创建和协调工作. 所谓IOC,对于Spring框架来说,就是由spring来负责控制对象的生命周期和对象间的关系.所有类的创建和销毁都由spring来控制. Spring 运行原理12345public static void main(String args[])&#123; ApplicationContext context = new FileSystemXmlApplicationContext(&quot;applicationContext.cml&quot;)); Animal animal = (Animal)context.getBean(&quot;animal&quot;); animal.say();&#125; applicationContext.xml 123&lt;bean id=&quot;animal&quot; class=&quot;com.xiaobai.pojo.Cat&quot;&gt; &lt;proterty name=&quot;name&quot; value=&quot;kitty&quot; /&gt;&lt;/bean&gt; Cat 类 123456789public class Cat implements Animal&#123; private String name; public void say()&#123; System.out.println(&quot;I am&quot; + name + &quot;!&quot;); &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; Animal 接口 123public interface Animal&#123; public void say();&#125; 输出 I am kitty! Spring是如何做到的呢？首先定义一个Bean类，这个类用来存放一个Bean拥有的属性。 123456/* Bean Id */private String id;/* Bean Class */private String type;/* Bean Property */private Map&lt;String,Object&gt; properties = new HashMap&lt;String,Object&gt;(); 一个Bean包括 id, type和 Properties。 接下来Spring开始加载配置文件，将配置的信息保存在一个HashMap中，HashMap的key就是Bean的Id，HashMap的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spring可以注入基本类型，而且可以注入像List，Map这样的类型，接下来以Map为例看看Spring是如何保存的。 Map 配置如下： 123456789101112&lt;bean id=&quot;test&quot; class=&quot;Test&quot;&gt; &lt;property name=&quot;testMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot;&gt; &lt;value&gt;1&lt;/value&gt; &lt;/entry&gt; &lt;entry key=&quot;b&quot;&gt; &lt;value&gt;2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; Spring 如何保存上面的配置?代码如下 12345678910111213141516171819202122if(beanProperty.element(&quot;map&quot;)!=null)&#123; Map&lt;String,Object&gt; propertiesMap = new HashMap&lt;String,Object&gt;(); Element propertiesListMap = (Element)beanProperty.elements().get(0); Iterator&lt;?&gt; propertiesIterator = propertiesListMap.elements().iterator(); while(propertiesITerator.hasNext())&#123; Element vet = (ELement)propertiesIterator.next(); if(vet.getName().equals(&quot;entry&quot;))&#123; String key = vet.attributeValue(&quot;key&quot;); Iterator&lt;?&gt; = valuesIterator = vet.elements().iterator(); while(valuesIterator.hasNext())&#123; Element value = (Element)valuesIterator.next(); if(value.getName().equals(&quot;value&quot;))&#123; propertiesMap.put(key,value.getText()); &#125; if(value.getName().equals(&quot;ref&quot;)）&#123; propertiesMap.put(key,new String[]&#123; value.attributeValue(&quot;bean&quot;) &#125;); &#125; &#125; &#125; &#125; bean.getProperties().put(name,propertiesMap);&#125; 接下是核心部分，其实依赖注入(DI)思想是通过反射机制实现的。在实例化一个类时，它是通过调用类中set方法将实现保存在HashMap中的类属性注入到类中。 首先实例化一个类，像这样 123456789101112131415public static Object newInstance(String className)&#123; Class&lt;?&gt; cls = null; Object obj = null; try&#123; cls = Class.forName(className); obj = cls.newInstance(); &#125;catch(ClassNotFoundException e)&#123; throw new RuntimeException(e); &#125;catch(InstantiationException e)&#123; throw new RuntimeException(e); &#125;catch(IllegalAccessException e)&#123; throw new RuntimeException(e); &#125; return obj;&#125; 接着将这个类的依赖注入进去，像这样 123456789101112131415161718192021222324public static void setProperty(Object obj,String name,String value)&#123; Class&lt;? extends Object&gt; clazz = obj.getClass(); try&#123; String methodName = ewturn SetMethodName(name); Method[] ms = clazz.getMethods(); for(Method m:ms)&#123; if(m.getName().equals(methodName))&#123; if(m.getParameterTypes().length == 1)&#123; Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[0]; setFieldValue(clazzParameterType.getName(),value,m,obj); break; &#125; &#125; &#125; &#125;catch(SecurityException e)&#123; throw new RuntimeException(e); &#125;catch(IllegalArgumentException e)&#123; throw new RuntimeException(e); &#125;catch(IllegalAcessException e)&#123; throw new RuntimeException(e); &#125;catch(InvocationTargetException e)&#123; throw new RuntimeException(e); &#125;&#125; 最后它将这个类的实例返回给我们，我们就可以用了。以Map为例看看它是怎么做的创建一个HashMap并注入到需要注入的类中 12345678910111213if (value instanceof Map) &#123; Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet() .iterator(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); while (entryIterator.hasNext()) &#123; Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next(); if (entryMap.getValue() instanceof String[]) &#123; map.put((String) entryMap.getKey(), getBean(((String[]) entryMap.getValue())[0])); &#125; &#125; BeanProcesser.setProperty(obj, property, map); &#125; 喝水不忘挖井人参考链接：http://blog.csdn.net/shenghuaday/article/details/51399433]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring 常见面试题]]></title>
    <url>%2F2017%2F09%2F12%2Fspring-exam%2F</url>
    <content type="text"><![CDATA[Spring 常见面试题Spring 概述 什么是 Spring ？ Spring是一个开源的java ee开发框架。Spring框架的核心功能可以应用在任何java应用程序中，但是对java ee平台上的web程序有更好的扩展性。Spring 框架的目标是使的java ee应用程序的应用开发更加便捷，通过使用pojo为基础的编程模型促进良好的编程风格。 Spring有那些优点？ 轻量级：Spring在大小和透明性方面是轻量级的，基础版本的Spring框架大约只有2MB。 控制反转(IOC)：Spring 使用控制反转技术实现了松耦合。依赖被注入的对象，而不是创建或者寻找依赖对象。 面向切面编程(AOP):Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 容器:Spring包含并管理应用程序对象的配置和生命周期。 MVC框架：Spring 的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。 事务管理:Spring 对下至本地业务上至全局业务(JAT)提供了同一的事务管理借口。 异常处理：Spring提供了一个方便的API将特定技术的异常(由JDBC,Hibernate,或JDO抛出)转化为一致的、Unchecked异常。 Spring 框架有哪些模块？ 基本模块： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaciton module Web module Web-Servlet module Web-Structs module Web-Portlet module 解释核心容器(应用上下文)模块 Spring 的基本模块，提供Spring的基本功能。BeanFactory是所有Spring应用的核心。Sroing是建立在这个模块指数上的，这也使Spring成为一个容器。 BeanFactory 和 Beanfactory 实例 BeanFactory 是工厂模式的一种实现，它使用控制反转(IOC)将应用的配置和依赖与实际的应用代码分离开来。最常用的BeanFactory 是 XmlBeanFactory类。 XmlBeanFactory 最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。 解释AOP模块 AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。 解释抽象JDBC和DAO模块 通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。 解释对象/关系映射集成模块 Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。 解释Spring MVC模块 Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。 Spring的配置文件 Spring的配置文件是一个XML文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。 Spring IoC容器是什么？ Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。 IOC有什么优点？ IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。 Spring中的依赖注入是什么？ 依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。 有哪些不同类型的IOC(依赖注入)？ 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。 Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。 Spring Beans 什么是Spring Beans？ Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。 在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。 Spring Bean中定义了什么内容？ Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系. 如何向Spring 容器提供配置元数据？ 有三种方式向Spring 容器提供元数据: XML配置文件 基于注解配置 基于Java的配置 基于 java 的配置 你如何定义bean的作用域？ 在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候用过“scope”属性定义即可。例如，当Spring需要每次产生一个新的实例，应该声明bean的scope属性为prototype。如果每次希望Spring返回一个实例，应该声明bean的scope属性为singleton。 说一下Spring中支持的bean作用域 Spring框架支持如下五种不同的作用域： singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。 prototype：一个bean可以定义多个实例。 request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。 session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境. globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境. bean默认的scope属性是’singleton‘。 解释Spring框架红bean的声明周期 Spring容器读取XML文件中bean的定义并实例化bean。 Spring根据bean的定义设置属性值。 如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。 如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。 如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。 如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。 如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。 如果该bean实现了DisposableBean，调用destroy()方法。 什么是bean自动装配？ Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和property元素。 解释自动装配的各种模式？ 自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入: no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。 byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为* byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。 constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。 autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。 Spring 注解 什么是Spring基于java的配置？ 基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。 以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。 什么是基于注解的容器配置? 另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。 如何开启注解装配？ 注解装配默认情况下在Spring容器中是不开启的。如果想要开启基于注解的装配只需在Spring配置文件中配置元素即可。 @Required 注解 @Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。如果bean的属性未设置，则抛出BeanInitializationException异常。 @Autowired 注解 @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。 @Qualifier 注解 当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。 Spring 数据访问 在Spring框架中如何更有效的使用JDBC？ 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和queries语句从数据库中存取数据。Spring框架中通过使用模板类能更有效的使用JDBC，也就是所谓的JdbcTemplate(例子)。 JdbcTemplate JdbcTemplate类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。 Spring对DAO的支持 Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。 使用Spring可以通过什么方式访问Hibernate？ 使用Spring有两种方式访问Hibernate： 使用Hibernate Template的反转控制以及回调方法 继承HibernateDAOSupport，并申请一个AOP拦截器节点 Spring支持的ORM Spring支持一下ORM： Hibernate iBatis JPA (Java -Persistence API) TopLink JDO (Java Data Objects) OJB 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？ 使用Spring的SessionFactory 调用LocalSessionFactory。结合过程分为以下三步： 配置Hibernate SessionFactory 继承HibernateDaoSupport实现一个DAO 使用AOP装载事务支持 Spring支持的事务管理类型 Spring支持如下两种方式的事务管理： 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。 Spring框架的事务管理有哪些优点？ 它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。 它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA). 它支持声明式事务管理。 它可以和Spring 的多种数据访问技术很好的融合。 你更推荐那种类型的事务管理？ 许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。 Spring面向切面编程(AOP) 解释AOP 面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。 切面(Aspect) AOP的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组API提供 cross-cutting功能。例如,日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。 在Spring AOP中concern和 cross-cutting concern的区别是什么？ Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。 Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。 连接点(Join point) 连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。 通知(Advice) 通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。 Spring切面可以执行一下五种类型的通知: before(前置通知)：在一个方法之前执行的通知。 after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 after-returning(后置通知)：在某连接点正常完成后执行的通知。 after-throwing(异常通知)：在方法抛出异常退出时执行的通知。 around(环绕通知)：在方法调用前后触发的通知。 切入点(Pointcut) 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 什么是引入？ 引入允许我们在已有的类上添加新的方法或属性。 什么是目标对象？ 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。 什么是代理？ 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 有几种不同类型的自动代理？ BeanNameAutoProxyCreator：bean名称自动代理创建器 DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器 Metadata autoproxying：元数据自动代理 什么是织入？什么是织入应用的不同点？ 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。 解释基于XML Schema方式的切面实现 在这种情况下，切面由使用XML文件配置的类实现。 解释基于注解方式(基于@AspectJ)的切面实现 在这种情况下(基于@AspectJ的实现)，指的是切面的对应的类使用Java 5注解的声明方式。 Spring的MVC框架 什么是Spring的MVC框架？ Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。 DispatcherServlet Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。 WebApplicationContext WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。 什么是Spring MVC框架的控制器？ 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。 @Controller annotation @Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。 57.@RequestMapping annotation @RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。]]></content>
      <categories>
        <category>java</category>
        <category>Spring 框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 Redis 安装]]></title>
    <url>%2F2017%2F09%2F11%2Fredis-install%2F</url>
    <content type="text"><![CDATA[CentOS 下 Redis 安装本文已下载好redis包：redis-3.0.7.tar.gz 安装redis确定好安装目录，将redis包移动到指定目录进行解压安装 12345678# tar –xzvf redis-3.0.7.tar.gz# 首先将解压文件改名# mv redis-3.0.7 redis#进入redis路径# cd /usr/local/redis/src# make &amp;&amp; make install ##安装编译 验证是否安装成功 1# redis-server –version 启动redis12# 进入redis安装路径 /usr/local/src/redis/src# redis-server 查看进程1# ps aux | grep redis 清除redis缓存1# redis-cli flushdb Redis远程连接需要关闭防火墙： 关闭防火墙—–service iptables stop 启动防火墙—–service iptables start 重启防火墙—–service iptables restart 查看防火墙状态–service iptables status 永久关闭防火墙–chkconfig iptables off 永久关闭后启用–chkconfig iptables on 修改配置文件redis.conf：123# bind 127.0.0.1 取消注释bind 127.0.0.1 取消requirepass foobar注释 远程登录：进入redis根目录，12# redis-cli –h 192.168.17.135 –p 6379# redis-cli –h 192.168.17.135 –p 6379 shutdown //服务停止 采用RedisStudio图形工具观察。 Redis自启动配置Utils文件夹在 redis 根目录下首先将utils/redis_init_script文件复制到/etc/init.d下，同时易名为redis1# cp/usr/local/redis/utils/redis_init_script /etc/rc.d/init.d/redis /usr/local/redis是redis的安装路径1# vim /etc/rc.d/init.d/redis 在文档的第二行添加1# chkconfig：2345 80 90 如果 /usr/local/bin 中没有redis-server和redis-cli，从redis目录中复制过来。在文档的 文档中：1CONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot; 将redis配置文件拷贝到 /etc/redis/路径下1234# mkdir /etc/redis# cp /usr/src/redis/redis.conf /etc/redis/6379.conf# vim /etc/rc.d/init.d/redis 将redis_${REDISPORT}.pid修改为redis.pid。 结果图：！ $ EXEC $ CONF 后边加一个 &amp; ，表示让redis作为后台服务启动，否则该服务会独占输入屏。 完成上面操作，注册服务：1# chkconfig --add redis 然后启动redis服务：1# service redis start 关闭redis服务：1# service redis stop]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scrapy分布式搭建]]></title>
    <url>%2F2017%2F09%2F11%2Fscrapy-redis%2F</url>
    <content type="text"><![CDATA[Scrapy 分布式部署使用scrapy-redis 插件实现scrapy分布式 1# pip install scrapy-redis 配置 redis 打开项目 settings.py,做如下修改: 123456SCHDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;SCHEDULER_PERSIST = TrueSCHEDULER_QUEUE_CLASS = &apos;scrapy_redis.queue.SpiderPriorityQueue&apos;REDIS_URL = NoneREDIS_HOST = &apos;127.0.0.1&apos;REDIS_PORT = 6379 Master 端 REDIS_HOST = ‘127.0.0.1’ REDIS_PORT = 6379Slave 端 REDIS_URL = ‘redis://192.168.17.134:6379’192.168.17.134 是Master端的机器IP]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Scrapyd 运行爬虫 API]]></title>
    <url>%2F2017%2F09%2F11%2Fscrapyd-scrapy%2F</url>
    <content type="text"><![CDATA[运行爬虫1$ curl http://localhost:6800/schedule.json -d project=myproject -d spider=somespider 终止爬虫1$ curl http://localhost:6800/cancel.json -d project=myproject -d job=6487ec79947edab326d6db28a2d86511e8247444 查看项目列表1$ curl http://localhost:6800/listprojects.json 查看版本列表1$ curl http://localhost:6800/listversions.json?project=myproject 查看爬虫列表1$ curl http://localhost:6800/listspiders.json?project=myproject 查看工作爬虫列表1$ curl http://localhost:6800/listjobs.json?project=myproject 删除某版本项目1$ curl http://localhost:6800/delversion.json -d project=myproject -d version=r99 删除某项目1$ curl http://localhost:6800/delproject.json -d project=myproject]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scrapyd 部署scrapy]]></title>
    <url>%2F2017%2F09%2F11%2Fscrapyd%2F</url>
    <content type="text"><![CDATA[Scrapyd部署scrapy项目打开项目根目录1# cd /usr/project/sinaSpider(projectname) 编辑 scrapy.cfg deploy后加target，同时将url的注释去掉 执行部署命令：1# scrapyd-deploy target –p projectname 也就是：1# scrapyd-deploy scrapyd –p sinaSpider 使用 supervisor 对scrapyd 进行管理防止 scrapyd 经常挂掉 scrapyd 配置文件如果设置了scrapyd的配置文件,scrapyd 会搜索如下路径：12345• /etc/scrapyd/scrapyd.conf (Unix)• c:\scrapyd\scrapyd.conf (Windows)• /etc/scrapyd/conf.d/* (in alphabetical order, Unix)• scrapyd.conf• ~/.scrapyd.conf (users home directory) 我的配置文件存储路径：1etc/scrapyd/scrapyd.conf 配置文件内容：1234567891011121314151617181920212223242526[scrapyd]eggs_dir = /usr/scrapyd/eggs # 爬虫部署存储路径logs_dir = /usr/scrapyd/logs # 爬虫日志文件存储路径jobs_to_keep = 100dbs_dir = /usr/scrapyd/dbsmax_proc = 0max_proc_per_cpu = 800 # 每台cpu 可运行的scrapy爬虫进程finished_to_keep = 100poll_interval = 5.0bind_address = 192.168.17.30 # 机器地址iphttp_port = 6800debug = offrunner = scrapyd.runnerapplication = scrapyd.app.applicationlauncher = scrapyd.launcher.Launcherwebroot = scrapyd.website.Root[services]schedule.json = scrapyd.webservice.Schedulecancel.json = scrapyd.webservice.Canceladdversion.json = scrapyd.webservice.AddVersionlistprojects.json = scrapyd.webservice.ListProjectslistversions.json = scrapyd.webservice.ListVersionslistspiders.json = scrapyd.webservice.ListSpidersdelproject.json = scrapyd.webservice.DeleteProjectdelversion.json = scrapyd.webservice.DeleteVersionlistjobs.json = scrapyd.webservice.ListJobs 为scrapyd 添加守护进程(supervisor) 安装supeervisor 1# pip install supervisor 在 构建supervisor的配置文件：1# echo_supervisord_conf &gt; /etc/supervisord.conf 修改配置文件： 1234567891011121314151617181920[unix_http_server]file=/tmp/supervisor.sock ; (the path to the socket file)chmod=0775 ; socket file mode (default 0700)[inet_http_server] ; inet (TCP) server disabled by defaultport=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface) # web服务的IP和端口号username=user ; (default is no username (open server)) # 登录web界面的用户名password=123 ; (default is no password (open server)) # 登录web界面的密码[supervisord]logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log)logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB)logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace)pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid)nodaemon=false ; (start in foreground if true;default false)minfds=1024 ; (min. avail startup file descriptors;default 1024)minprocs=200 ; (min. avail process descriptors;default 200)[supervisorctl]serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket[include]files = /etc/supervisor/*.conf 在etc 下建立文件夹 supervisor建立守护进程配置文件scrapyd.conf 内容： 1234[program:scrapyd]command=/usr/local/bin/scrapyd # scrapyd 的执行路径autostart=trueautorestart=true 设置supervisor开机自启动： 在 /etc/init.d 文件夹下建立脚本文件 supervisord内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243#! /bin/sh#chkconfig: 2345 95 20 # description: Description of the script # processname: supervisordPATH=/usr/local/bin:/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/binPROGNAME=supervisordDAEMON=/usr/local/bin/$PROGNAMECONFIG=/etc/$PROGNAME.confPIDFILE=/var/run/$PROGNAME.pidDESC=&quot;supervisord daemon&quot;SCRIPTNAME=/etc/init.d/$PROGNAME# Gracefully exit if the package has been removed.test -x $DAEMON || exit 0start()&#123; echo -n &quot;Starting $DESC: $PROGNAME&quot; $DAEMON -c $CONFIG echo &quot;...&quot;&#125;stop()&#123; echo -n &quot;Stopping $DESC: $PROGNAME&quot; supervisor_pid=$(cat $PIDFILE) kill -15 $supervisor_pid echo &quot;...&quot;&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; restart) stop start ;; *) echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart&#125;&quot; &gt;&amp;2 exit 1 ;;esacexit 0 保存后修改文件权限：12345678# chmod 777 /etc/init.d/supervisord# /etc/init.d/supervisord start或者# service supervisord start配置开机自启动：# chkconfig supervisord on]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos下Scrapy环境搭建]]></title>
    <url>%2F2017%2F09%2F11%2Fcentos-python%2F</url>
    <content type="text"><![CDATA[Scrapy 环境搭建 Centos 6.5 默认python2.6 ,但是scrapy 支持 python &gt;=2.7 scrapy python2.7 Vmware xshell 升级python1# [root@localhost ~]# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz 进入路径并编译：1234567891011[root@localhost ~]# tar zxf Python-2.7.3.tgz[root@localhost ~]# cd Python-2.7.3[root@localhost Python-2.7.3]# ./configure[root@localhost Python-2.7.3]#make &amp;&amp; make install[root@localhost Python-2.7.3]# mv /usr/bin/python /usr/bin/python_old[root@localhost Python-2.7.3]# python --version-bash: /usr/bin/python: No such file or directory[root@localhost Python-2.7.3]# ln -s /usr/local/bin/python2.7 /usr/bin/python[root@localhost Python-2.7.3]# python --versionPython 2.7.3 更改yum的配置文件（因为升级到python2.7之后，原来的yum就无法使用了）1[root@localhost Python-2.7.3]# vim /usr/bin/yum 1[root@localhost Python-2.7.3]# yum intall zlib-devel 再重新编译python2.7 easy_install 安装首先安装 openssl 和 openssl-devel12345678# yum install openssl# yum install openssl-devel# wget --no-cookie --no-check-certificate http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz# tar xzvf setuptools-0.6c11.tar.gz# cd setuptools-0.6c11# python setup.py build# python setup.py install pip安装123456789# yum install openssl# yum install openssl-devel# ./configure# make &amp;&amp; make install# wget &quot;https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz#md5=834b2904f92d46aaa333267fb1c922bb&quot; --no-check-certificate# tar -xzvf pip-1.5.4.tar.gz# cd pip-1.5.4# python setup.py install Scrapy 安装安装依赖Twisted 依赖 bzip2-devel12345678910111213141516171819# yum install bzip2-devel依赖 lxml# yum install lxml依赖 w3lib# yum install w3lib报 Unicode 错误# easy_install Cython# yum install libxslt-devel libxml2-devel llibffi-devel# yum install gcc libffi-devel# pip install pydispatcher# yum install sqlite-devel缺少 cryptography 包# yum install cryptography# pip install scrapy Scrapyd 安装123456# pip install attrs# easy_install pyasnl-modules# easy_install pyasnl# pip install scrapyd# pip install scrapyd-client# scrapyd 在虚拟机中打开浏览器输入 localhost：6800 环境搭建完成，可能在安装的过程中，需要安装其他的包，缺什么就pip安装什么就可以。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java-PriorityQueue实现最大堆和最小堆]]></title>
    <url>%2F2017%2F09%2F10%2Fzuidaduiandzuixiaodui%2F</url>
    <content type="text"><![CDATA[PriorityQueue 实现最大堆和最小堆概念：堆是一种经过排序的完全二叉树，其中任一非终端节点的数值均不大于(或不小于)其左孩子和右孩子的节点。 * 最小堆(小根堆) 根节点(堆顶)的值在堆里是最小的堆,称为最小堆 * 最大堆(大根堆) 根节点(堆顶)的值在堆里是最大的堆,称为最大堆 借助PriorityQueue 可以实现小根堆和大根堆。 PriorityQueue 的容量没有界限,并且默认排序是自然排序,队头元素是最小元素,可以拿来做最小堆使用(注意：默认的PriorityQueue并非保证了整个队列是有序的,只是保证了队头是最小的) 对于大根堆,就要借助于comparator比较器实现最大堆。(默认的初始容量：11) 代码实现： 123456PriorityQueue &lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(11,new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1,Integer o2)&#123; return o2.compareTo(o1); &#125;&#125;) 最大堆和最小堆实例：已知关键字序列5,8,12,19,28,20,15,22是最小堆，插入关键字3，调整后得到的最小堆是() 算法实例：题目描述(数据流中的中位数)如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738import java.util.PriorityQueue;import java.util.Comparator;/** 最大堆中 放 较小的一半， 最小值放较大的一半* 如果是奇数个，就最大堆数量比最小堆数量大 1，如果是偶数，取最大堆得的最小值和最小堆得最大值的平均数*/public class Solution &#123; private int count = 0; private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;(); private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(11,new Comparator&lt;Integer&gt;()&#123; public int compare(Integer o1,Integer o2)&#123; return o2.compareTo(o1); &#125; &#125;); public void Insert(Integer num) &#123; if(count % 2 == 1)&#123; // 如果是偶数，放入最小堆中 maxHeap.offer(num); minHeap.offer(maxHeap.poll()); &#125;else&#123; // 如果是奇数，放入最大堆中 minHeap.offer(num); maxHeap.offer(minHeap.poll()); &#125; count++; &#125; // 如果是奇数，就取最大堆中的最大值，如果是偶数，就取最大堆中的最大值和最小堆中的最小值的平均值 public Double GetMedian() &#123; if(count % 2 == 0)&#123; return new Double((maxHeap.peek()+minHeap.peek()))/2; &#125;else&#123; return new Double(maxHeap.peek()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-equals方法和hashCode方法]]></title>
    <url>%2F2017%2F09%2F09%2Fjava-hashmap%2F</url>
    <content type="text"><![CDATA[HashMap工作原理Object类的两个方法： 1234567/** JNI ,调用底层其他语言实现*/public native int hashCode();/** 默认同==,直接比较对象 */public boolean equals(Object o)&#123; return (this == o);&#125; hashCode是本地方法,返回的是对象的地址值。对象的equals()比较的是两个对象的地址值,如果equals()相等,hashCode()肯定也相等。 String 类中重写了equals方法，比较的是字符串的值，源码实现: 12345678910111213141516171819202122public boolean equals(Object o)&#123; if(this == o)&#123; return true; &#125; if(o instanceof String)&#123; String anString = (String)o; int n = value.length; if(n == anString.value.length)&#123; char[] v1 = value; char[] v2 = anString.value; int i = 0; while(n-- != 0)&#123; if(v1[i] != v2[i])&#123; return false; &#125; i++; &#125; return true; &#125; &#125; return false;&#125; 重写equals的四个条件： 自反性：对于任何非空引用值x，x.equals(x)都返回true。 对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值x,x.equals(null)都应返回 false。 Object 对象: 对于任何非空引用值 x 和 y,当且仅当 x 和 y 引用同一个对象时,此方法才返回 true。 当equals重写时,hashCode 方法也要重写。 相同的对象必须有相同的哈希码。 equals() 相等的两个对象,hashCode()一定相等;equals 不相等的两个对象,不能证明他们的hashCode不相等.可能是由于哈希碰撞产生的。hashCode()不相等的两个对象,equals也肯定不相等。 下面看一个具体的例子： 1234567891011121314151617181920212223242526272829303132333435package com.xiaobai.demo; public class RectObject &#123; public int x; public int y; public RectObject(int x,int y)&#123; this.x = x; this.y = y; &#125; @Override public int hashCode()&#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj)&#123; if(this == obj) return true; if(obj == null) return false; if(getClass() != obj.getClass()) return false; final RectObject other = (RectObject)obj; if(x != other.x)&#123; return false; &#125; if(y != other.y)&#123; return false; &#125; return true; &#125; &#125; 重写了父类Object中的hashCode和equals方法，看到hashCode和equals方法中，如果两个RectObject对象的x,y值相等的话他们的hashCode值是相等的，同时equals返回的是true;下面是测试代码： 123456789101112131415package com.xiaobai.demo; import java.util.HashSet; public class Demo &#123; public static void main(String[] args)&#123; HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;(); RectObject r1 = new RectObject(3,3); RectObject r2 = new RectObject(5,5); RectObject r3 = new RectObject(3,3); set.add(r1); set.add(r2); set.add(r3); set.add(r1); System.out.println(&quot;size:&quot;+set.size()); &#125; &#125; 运行结果:size:2为什么会是2呢？这个很简单了吧，因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象 下面我们把RectObject对象中的hashCode方法注释，即不重写Object对象中的hashCode方法，在运行一下代码： 运行结果：size:3这个结果也是很简单的，首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3 下面我们把RectObject对象中的equals方法中的内容注释，直接返回false，不注释hashCode方法，运行一下代码： 运行结果：size:3这个结果就有点意外了，我们来分析一下：首先r1和r2的对象比较hashCode，不相等，所以r2放进set中，再来看一下r3,比较r1和r3的hashCode方法，是相等的，然后比较他们两的equals方法，因为equals方法始终返回false,所以r1和r3也是不相等的，r3和r2就不用说了，他们两的hashCode是不相等的，所以r3放进set中，再看r4,比较r1和r4发现hashCode是相等的，在比较equals方法，因为equals返回false,所以r1和r4不相等，同一r2和r4也是不相等的，r3和r4也是不相等的，所以r4可以放到set集合中，那么结果应该是size:4,那为什么会是3呢？这时候我们就需要查看HashSet的源码了，下面是HashSet中的add方法的源码： 123456789101112131415/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null ? e2==null : e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; 这里我们可以看到其实HashSet是基于HashMap实现的，我们在点击HashMap的put方法，源码如下： 12345678910111213141516171819202122232425262728293031/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 我们主要来看一下if的判断条件，首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。 最后我们在来看一下hashCode造成的内存泄露的问题：看一下代码：1234567891011121314151617package com.xiaobai.demo; import java.util.HashSet; public class Demo &#123; public static void main(String[] args)&#123; HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;(); RectObject r1 = new RectObject(3,3); RectObject r2 = new RectObject(5,5); RectObject r3 = new RectObject(3,3); set.add(r1); set.add(r2); set.add(r3); r3.y = 7; System.out.println(&quot;删除前的大小size:&quot;+set.size()); set.remove(r3); System.out.println(&quot;删除后的大小size:&quot;+set.size()); &#125; &#125; 运行结果：删除前的大小size:3删除后的大小size:3 发现一个问题了，而且是个大问题呀，我们调用了remove删除r3对象，以为删除了r3,但事实上并没有删除，这就叫做内存泄露，就是不用的对象但是他还在内存中。所以我们多次这样操作之后，内存就爆了。看一下remove的源码： 123456789101112131415/** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null ? e==null : o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; 然后再看一下remove方法的源码： 12345678910111213/** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; 在看一下removeEntryForKey方法源码：12345678910111213141516171819202122232425262728293031/** * Removes and returns the entry associated with the specified key * in the HashMap. Returns null if the HashMap contains no mapping * for this key. */ final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; 我们看到，在调用remove方法的时候，会先使用对象的hashCode值去找到这个对象，然后进行删除，这种问题就是因为我们在修改了r3对象的y属性的值，又因为RectObject对象的hashCode方法中有y值参与运算,所以r3对象的hashCode就发生改变了，所以remove方法中并没有找到r3了，所以删除失败。即r3的hashCode变了，但是他存储的位置没有更新，仍然在原来的位置上，所以当我们用他的新的hashCode去找肯定是找不到了。其实上面的方法实现很简单的：如下图： 很简单的一个线性的hash表，使用的hash函数是mod,源码如下： 123456/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 这个其实就是mod运算，只是这种运算比%运算要高效。1,2,3,4,5表示是mod的结果，每个元素对应的是一个链表结构，所以说想删除一个Entry的话，首先得到hashCode，从而获取到链表的头结点，然后再遍历这个链表，如果hashCode和equals相等就删除这个元素。上面的这个内存泄露告诉我一个信息：如果我们将对象的属性值参与了hashCode的运算中，在进行删除的时候，就不能对其属性值进行修改，否则会出现严重的问题。 其实我们也可以看一下8种基本数据类型对应的对象类型和String类型的hashCode方法和equals方法。其中8中基本类型的hashCode很简单就是直接返回他们的数值大小，String对象是通过一个复杂的计算方式，但是这种计算方式能够保证，如果这个字符串的值相等的话，他们的hashCode就是相等的。8种基本类型的equals方法就是直接比较数值，String类型的equals方法是比较字符串的值的。 参考:http://blog.csdn.net/jiangwei0910410003/article/details/22739953]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串中找出连续最长的数字串]]></title>
    <url>%2F2017%2F09%2F09%2FFindLongNum%2F</url>
    <content type="text"><![CDATA[题目描述读入一个字符串str，输出字符串str中的连续最长的数字串 输入描述:个测试输入包含1个测试用例，一个字符串str，长度不超过255。 输出描述:在一行内输出str中里连续最长的数字串。 示例11234输入abcd12345ed125ss123456789输出123456789 思路： 1. 定义一个值，数字字符串的长度 2. 定义StringBuilder，保存数字字符串 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); String s = in.nextLine(); char[] ch = s.toCharArray(); int max = 0; // 保存最终最大值的长度 int temp = 0; // 保存当前连续数字字符串的长度 String result = &quot;&quot;; // 保存对吼的字符串结果 StringBuilder sb = new StringBuilder(); // 保存当前的连续数字字符串 for(int i=0;i&lt;ch.length;i++)&#123; if(Character.isDigit(ch[i]))&#123; temp++; sb.append(ch[i]); &#125;else&#123; sb.delete(0,sb.length()); temp = 0; &#125; if(temp &gt; max)&#123; max = temp; result = sb.toString(); &#125; &#125; System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fibonacci 数列]]></title>
    <url>%2F2017%2F09%2F09%2Ffibonacci%2F</url>
    <content type="text"><![CDATA[题目描述Fibonacci数列是这样定义的：F[0] = 0F[1] = 1for each i ≥ 2: F[i] = F[i-1] + F[i-2]因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, …，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。 输入描述输入为一个正整数N(1 ≤ N ≤ 1,000,000) 输出描述输出一个最小的步数变为Fibonacci数” 思路： 判断 N 与相邻两个数的差的大小，以 N 作为界限 代码实现1234567891011121314151617import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int Num = in.nextInt(); int a = 0; int b = 1; while(b&lt;=Num)&#123; int tmp = a + b; a = b; b = tmp; &#125; int result = (b-Num)&gt;(Num-a)?(Num-a):(b-Num); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2017%2F09%2F08%2Ftreenode-reconstruct%2F</url>
    <content type="text"><![CDATA[重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 前序遍历根左右 中序遍历左根右 后序遍历左右根 思路： 已知前序遍历和中序遍历的结果，前序遍历可以推出 根节点，中序遍历可以推出左子树和右子树 例如： * 前序遍历序列： {1,2,4,7,3,5,6,8} 确认根节点为 1 * 中序遍历序列： {4,7,2,1,5,3,8,6} 找到根节点索引，根节点左边即为左子树：{4,7,2} ，右子树：{5,3,8,6} * 依次确定： * 左子树 前序遍历为 {2,4,7} 中序遍历为 {4,7,2} * 右子树 前序遍历为 {3,5,6,8} 中序遍历为 {5,3,8,6} .... 代码实现：12345678class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Solution&#123; public static void main(String args[])&#123; int[] pre = &#123;1,2,4,7,3,5,6,8&#125;; int[] in = &#123;4,7,2,1,5,3,8,6&#125;; TreeNode result = TreeNodeConstruct(pre,in); &#125; public static TreeNode TreeNodeConstruct(int[] pre,int[] in)&#123; ArrayList&lt;Integer&gt; preList = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; inList = new ArrayList&lt;Integer&gt;(); for(int i:pre)&#123; preList.add(pre); &#125; for(int j:in)&#123; inList.add(j); &#125; return getRoot(preList,inList); &#125; public static TreeNode getRoot(List&lt;Integer&gt; preList,List&lt;Integer&gt; inList)&#123; if(preList.size() == 0)&#123; return null; &#125; int val = preList.get(0); // 获取根节点 TreeNode root = new TreeNode(val); int index = inList.indexOf(val); // 获取中序遍历序列中根节点的索引，从而确定中序遍历左子树和中序遍历右子树 // subList(preIndex,lastIndex) 截取List ,不包含lastIndex ,但是包含 preIndex List&lt;Integer&gt; inLeft = inList.subList(0,index); // 获取中序遍历左子树 List&lt;Integer&gt; inRight = inList.subList(index+1,inList.size()); // 获取中序遍历右子树 List&lt;Integer&gt; preLeft = preList.subList(1,inLeft.size()+1); // 获取前序遍历左子树 List&lt;Integer&gt; preRight = preList,subList(inLeft+1,preList.size()); // 获取前序遍历右子树 root.left = getRoot(preLeft,inLeft); root.right = getRoot(preRight,inRight); return root; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java-stack 类]]></title>
    <url>%2F2017%2F09%2F08%2Fjava-stack%2F</url>
    <content type="text"><![CDATA[JAVA Stack 类栈是Vector的一个子类，他是实现了一个标准的后进先出的栈。 方法： empty()测试堆栈是否为空。 peek()查看堆栈顶部的对象，但不从堆栈中移除它。 pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 push()把项压入堆栈顶部。 search()返回对象在堆栈中的位置，以 1 为基数。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入两个链表，找出它们的第一个公共结点。]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-commonnode%2F</url>
    <content type="text"><![CDATA[输入两个链表，找出它们的第一个公共结点。思路:使用 stack 1234567class LinkNode&#123; int val; LinkNode next = null; LinkNode(int val)&#123; this.val = val; &#125;&#125; 代码实现1234567891011121314151617181920212223import java.util.Stack;public class Solution&#123; public LinkNode FindCommonNode(LinkNode list1,LinkNode list2)&#123; Stack&lt;LinkNode&gt; stack1 = new Stack&lt;LinkNode&gt;(); Stack&lt;LinkNode&gt; stack2 = new Stack&lt;LinkNode&gt;(); LinkNode result = null; while(list1 != null)&#123; stack1.push(list1); list1 = list1.next; &#125; while(list2 != null)&#123; stack2.push(list2); list2 = list2.next; &#125; // 只要 两个链表中的值相等，就进入循环，直到循环结束，最后一次相等的值就是首次相等的值 while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty() &amp;&amp; stakc1.peek() == stack2.peek())&#123; stack1.pop(); result = stack2.pop(); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树转换成双向链表]]></title>
    <url>%2F2017%2F09%2F08%2FTwoTree-linklist%2F</url>
    <content type="text"><![CDATA[输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。思路： 利用二叉树的中序遍历是是递增的。 12345 5 3 81 4 6 9中序遍历(左根右): 1 3 4 5 6 8 9 代码实现： 12345678public class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode(int val)&#123; this.val = val; &#125;&#125; 123456789101112131415161718192021222324252627282930import java.util.Stack;public class Solution&#123; public TreeNode Convert(TreeNode root)&#123; if(root == null) return null; TreeNode p = root; TreeNode pre = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); boolean isFirst = true; // 确定首节点 while(p!=null || !stack.isEmpty())&#123; while(p != null!)&#123; stack.push(p); p = p.left; &#125; p = stack.pop(); // 确定首节点 if(isFirst)&#123; root = p; // 首节点 pre = root; // 前一节点 isFirst = fasle; &#125;else&#123; pre.right = p; // 前一节点右指向当前节点 p.left = pre; // 当前节点左指向前一节点 pre = p; //当前节点变为前一节点 &#125; p = pre.right; // 取右节点 &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并两个链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-merge-two%2F</url>
    <content type="text"><![CDATA[输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。非递归版本123456789/*public class ListNode&#123; int val; ListNode node = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution&#123; public ListNode merge(ListNode list1,ListNode list2)&#123; if(list1 == null) return list2; if(list2 == null) return list1; // 确定头结点 ListNode head = null; // 保存当前节点 ListNode current = null; // 当list1 和 list2 都不为空时，比较两个链表的值 while(list1 != null &amp;&amp; list2 != null)&#123; // 如果list1的值比list2的值较小 if(list1.val&lt;=list2.val)&#123; // 确定头结点 if(head == null)&#123; head = current = list1; &#125;else&#123; current.next = list1; // 保存当前节点 current = current.next; &#125; // 下一节点 list1 = list1.next; &#125;else&#123; // 确定头结点 if(head == null)&#123; head = current = list2; &#125;else&#123; current.next = list2; current = current.next; &#125; list2 = list2.next; &#125; &#125; if(list1 == null)&#123; current.next = list2; &#125; if(list2 == null)&#123; current.next = list1; &#125; return head; &#125;&#125; 递归版本1234567891011121314151617public class Solution&#123; public ListNode Merge(ListNode list1,ListNode list2)&#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val&lt;=list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入一个链表从尾到头进行打印]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-tail-head%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表输入一个链表，从尾到头打印链表每个节点的值。 思路：利用 栈 的先进后出的原则123456789/*public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122import java.util.Stack;import java.util.ArrayList;public class Solution&#123; public ArrayList&lt;Integer&gt; PrintTailToHead(ListNode node)&#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); if(node == null)&#123; return result; &#125; ListNode head = node; while(head.next != null)&#123; stack.push(head.val); head = head.next; &#125; stack.push(head.val); while(!stack.isEmpty())&#123; result.add(stack.pop()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻转链表]]></title>
    <url>%2F2017%2F09%2F08%2Flinklist-reverse%2F</url>
    <content type="text"><![CDATA[翻转链表1-&gt;2-&gt;3-&gt;4-&gt;5head = 1next = 2 1-&gt;2 保存1到2 的指针防止造成断链 null&lt;-1 2-&gt;3..-&gt;5head.next = pre 1-&gt;nullpre = 1head = next = 2 head = 2next = 3 2-&gt;3head.next = pre = 1 1&lt;-2-&gt;3..-&gt;5pre = head = 2head = next = 3… 123456789101112131415161718192021222324public class ListNode&#123; int val; ListNode next = null; ListNode(int val)&#123; this.val = val; &#125;&#125;public class Solution&#123; public ListNode ReverseList(ListNode listnode)&#123; if(listnode == null) return null; ListNode next = null; // 保存当前节点指向下一节点的指针 ListNode pre = null; // 保存当前节点的上一个节点 while(head != null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP&&UDP常见面试题]]></title>
    <url>%2F2017%2F09%2F07%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP协议和UDP协议的区别是什么 TCP保证数据按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，只是努力交付。 TCP协议所需资源较多，TCP首部需20字节（不算可选项），UDP首部字段只需8字节。 TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率。 TCP是一对一的连接，UDP支持一对一，多对多，一对多的通信。 TCP是面向的字节流的服务，UDP是面向的报文的服务。 请详细介绍TCP协议建立连接和终止连接的过程？ 建立连接：三次握手 关闭连接：四次挥手 常见的应用中有那些是应用TCP协议的，那些是UDP协议的，为什么？ 以下应用一般或必须使用UDP实现？ 多播的信息一定要用UDP实现，因为TCP只支持一对一通信。 如果一个应用场景中大多是简短的信息，适合用UDP实现，因为udp是基于报文的它直接上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输速率。 如果一个应用场景性能甚于完整性和安全性，那么适合udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达速度快，因此比较适合udp。 如果要求快速响应，那么udp比较合适。 如果有要利用udp的快速响应有点，又想可靠传输，那么只能靠上层应用自己制定规则。 常见的使用UDP的例子：ICQ，QQ的聊天模块。 以qq为例：登录采用TCP协议和http协议，和好友间的信息发送，主要用udp协议，内网文件传输采用p2p技术。 登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pyspider windows 下环境搭建]]></title>
    <url>%2F2017%2F09%2F07%2Fpyspider-environment%2F</url>
    <content type="text"><![CDATA[依赖 lxml（建议采用windows 编译好的） pycurl phantomjs(将 phantomjs.exe 放在python path 路径下即可) 建议采用 python2.7 32bit（windows环境下）1# pip install pyspider 注意：用pip下载的pyspider不是最新版本，在使用phantomjs进行渲染的时候，发现无法使用 代理 和 执行 js动作，需要更新pyspider 的 fetch_script.js 文件，[pyspider](https://github.com/binux/pyspider)地址 运行1# pyspider all 打开浏览器，输入 localhost:5000 即可dashboard 界面 点击 create ，填写项目名称，开始爬行之旅 搭建完成。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyspider</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lru 计算缺页]]></title>
    <url>%2F2017%2F09%2F07%2Flru%2F</url>
    <content type="text"><![CDATA[在一个请求页式存储管理中，一个程序的页面走向为 3、4、2、1、4、5、3、4、5、1、2，并采用 LRU 算法。设分配给该程序的存储块数 S 分别为 3 和 4，在该访问中发生的缺页次数 F 是 ?解： LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的。 123456789101112131415161718以下用x表示缺页的情况1.S=33,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 5 1 3 4 2 1 4 5 4 3 5x x x x x x x x所以F=82.S=43,4,2,1,4,5,3,4,5,1,2---------------------3 4 2 1 4 5 3 4 5 1 2 3 4 2 1 4 5 3 3 3 1 3 4 2 1 4 5 4 5 3 3 3 2 1 1 1 4 5x x x x x x x所以F=7]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下mysql的配置修改]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos1%2F</url>
    <content type="text"><![CDATA[linux下mysql的配置修改 使用CentOS下yum安装mysql mysql启动和停止等操作 12345678910111213141516# /etc/init.d/mysqld start;# service mysqld start;#service mysqld stop;#/etc/init.d/mysqld stop;# service mysqld restart;#/etc/init.d/mysqld restart;#service mysqld status;设置新的最大连接数为200：mysql&gt; set GLOBAL max_connections=200 显示当前运行的Query：mysql&gt; show processlist 显示当前状态：mysql&gt; show status 退出客户端：mysql&gt; exit mysql配置文件 以使用的MySQL配置文件共有５个。最后４个位于/usr/share/mysql-server-*/目录中。·/etc/my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。 mysql配置参数一般我们会把配置文件（例如：my-small.cnf）拷贝到/etc/my.cnf只需要修改这个配置文件就可以了，使用mysqladmin variables extended-status -u root -p可以看到目前的参数，有3个配置参数是最重要的，即123key_buffer_size,query_cache_size,table_cache。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 navicat 破解]]></title>
    <url>%2F2017%2F09%2F03%2Fmysql-centos%2F</url>
    <content type="text"><![CDATA[破解方案： 第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。 cd /home/hadoop/.navicat/此文件夹下有一个system.reg文件 rm system.reg 把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
</search>
